/* tslint:disable */
/* eslint-disable */
/**
 * PardoMart Node API
 * API documentation for the PardoMart Node.js application.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@pardomart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Ad {
    'id'?: string;
    'title'?: string;
    'description'?: string | null;
    'imageUrl'?: string;
    'vendorId'?: string;
    'isActive'?: boolean;
    'startDate'?: string;
    'endDate'?: string | null;
}
export interface AddCartItemPayload {
    'vendorProductId': string;
    'quantity': number;
}
export interface AuthInitiateLoginPost200Response {
    'success'?: boolean;
    'role'?: Role;
}


export interface AuthInitiateLoginPostRequest {
    'mobileNumber': string;
    'role': AuthInitiateLoginPostRequestRoleEnum;
}

export const AuthInitiateLoginPostRequestRoleEnum = {
    Customer: 'customer',
    Vendor: 'vendor',
    StoreAdmin: 'store_admin',
    StoreShopper: 'store_shopper',
    DeliveryPerson: 'delivery_person',
    Admin: 'admin'
} as const;

export type AuthInitiateLoginPostRequestRoleEnum = typeof AuthInitiateLoginPostRequestRoleEnum[keyof typeof AuthInitiateLoginPostRequestRoleEnum];

export interface AuthRegisterPostRequest {
    /**
     * The user\'s full name.
     */
    'name': string;
    /**
     * The user\'s email address.
     */
    'email': string;
    /**
     * The user\'s mobile number in E.164 format.
     */
    'mobileNumber': string;
    /**
     * The role for the new user.
     */
    'role': AuthRegisterPostRequestRoleEnum;
    /**
     * Required if role is \'store_shopper\'. The ID of the vendor this staff member belongs to.
     */
    'vendorId'?: string;
}

export const AuthRegisterPostRequestRoleEnum = {
    Customer: 'customer',
    Vendor: 'vendor',
    StoreAdmin: 'store_admin',
    StoreShopper: 'store_shopper',
    DeliveryPerson: 'delivery_person',
    Admin: 'admin'
} as const;

export type AuthRegisterPostRequestRoleEnum = typeof AuthRegisterPostRequestRoleEnum[keyof typeof AuthRegisterPostRequestRoleEnum];

export interface AuthTimeZonesGet200Response {
    'message'?: string;
    'data'?: Array<string>;
}
export interface AuthVerifyLoginPostRequest {
    'mobileNumber': string;
    'verificationCode': string;
    'role': AuthVerifyLoginPostRequestRoleEnum;
}

export const AuthVerifyLoginPostRequestRoleEnum = {
    Customer: 'customer',
    Vendor: 'vendor',
    StoreAdmin: 'store_admin',
    StoreShopper: 'store_shopper',
    DeliveryPerson: 'delivery_person',
    Admin: 'admin'
} as const;

export type AuthVerifyLoginPostRequestRoleEnum = typeof AuthVerifyLoginPostRequestRoleEnum[keyof typeof AuthVerifyLoginPostRequestRoleEnum];

export interface BugReportsIdStatusPatchRequest {
    /**
     * Set to true to mark the bug as resolved, false to mark it as unresolved.
     */
    'isResolved': boolean;
}
export interface CalculateFeesPayload {
    'orderItems': Array<CalculateFeesPayloadOrderItemsInner>;
    'vendorId': string;
    'deliveryAddressId': string;
}
export interface CalculateFeesPayloadOrderItemsInner {
    'vendorProductId': string;
    'quantity': number;
}
export interface CalculateFeesResponse {
    'subtotal'?: number;
    'shoppingFee'?: number;
    'deliveryFee'?: number;
    'serviceFee'?: number;
    'totalEstimatedCost'?: number;
}
export interface Cart {
    'id'?: string;
    'userId'?: string;
    'vendorId'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'cartItems'?: Array<CartItem>;
    'vendor'?: Vendor;
    'items'?: Array<CartItemWithProduct>;
}
export interface CartItem {
    'id'?: string;
    'cartId'?: string | null;
    'vendorProductId'?: string;
    'quantity'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
    'orderId'?: string | null;
    'vendorProduct'?: VendorProduct;
}
export interface CartItemWithProduct {
    'id'?: string;
    'cartId'?: string | null;
    'vendorProductId'?: string;
    'quantity'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
    'orderId'?: string | null;
    'vendorProduct'?: VendorProduct;
}
export interface CategoriesWithProductsResult {
    'parentCategories'?: Array<Category>;
    'subCategories'?: Array<VendorCategoryWithProducts>;
}
export interface Category {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'parentId'?: string | null;
    'type'?: CategoryTypeEnum;
    'imageUrl'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const CategoryTypeEnum = {
    Product: 'PRODUCT',
    Service: 'SERVICE'
} as const;

export type CategoryTypeEnum = typeof CategoryTypeEnum[keyof typeof CategoryTypeEnum];

export interface CategoryDetailsResult {
    'category'?: Category;
    'stores'?: Array<StoreWithLimitedProducts>;
}
export interface CategoryOverview {
    /**
     * The total number of top-level categories.
     */
    'totalParentCategories'?: number;
    /**
     * The total number of categories that are children of another category.
     */
    'totalSubCategories'?: number;
}
export interface CategorySummary {
    'id'?: string;
    'name'?: string;
}

export const ContentType = {
    PrivacyPolicy: 'PRIVACY_POLICY',
    TermsOfService: 'TERMS_OF_SERVICE'
} as const;

export type ContentType = typeof ContentType[keyof typeof ContentType];


export interface CreateCategoriesBulkPayload {
    'categories': Array<CreateCategoryPayload>;
}
export interface CreateCategoryPayload {
    'name': string;
    /**
     * The ID of the parent category, if this is a sub-category.
     */
    'parentId'?: string | null;
    'type': CreateCategoryPayloadTypeEnum;
    'imageUrl'?: string | null;
}

export const CreateCategoryPayloadTypeEnum = {
    Product: 'PRODUCT',
    Service: 'SERVICE'
} as const;

export type CreateCategoryPayloadTypeEnum = typeof CreateCategoryPayloadTypeEnum[keyof typeof CreateCategoryPayloadTypeEnum];

export interface CreateDeliveryAddressPayload {
    'addressLine1': string;
    'addressLine2'?: string | null;
    'city': string;
    'state'?: string | null;
    'postalCode'?: string | null;
    'country': string;
    /**
     * If true, this will become the user\'s new default address.
     */
    'isDefault'?: boolean;
    'latitude'?: number | null;
    'longitude'?: number | null;
    'label'?: string | null;
}
export interface CreateFaqPayload {
    'question': string;
    'answer': string;
    'isActive'?: boolean;
    'sortOrder'?: number;
}
export interface CreateFeePayload {
    'type': FeeType;
    'amount': number;
    'description'?: string | null;
    'isActive': boolean;
    'method': FeeCalculationMethod;
    'unit'?: string | null;
    'minThreshold'?: number | null;
    'maxThreshold'?: number | null;
    'thresholdAppliesTo'?: string | null;
}


export interface CreateOrderClientPayload {
    'vendorId': string;
    'paymentMethod': PaymentMethods;
    /**
     * ID of an existing delivery address. Required if `deliveryMethod` is `delivery_person`.
     */
    'shippingAddressId'?: string | null;
    /**
     * Optional. Tip for the shopper.
     */
    'shopperTip'?: number;
    /**
     * Optional. Tip for the delivery person.
     */
    'deliveryPersonTip'?: number;
    'deliveryInstructions'?: string | null;
    'orderItems': Array<CreateOrderClientPayloadOrderItemsInner>;
    'shoppingMethod': ShoppingMethod;
    'deliveryMethod': DeliveryMethod;
    'scheduledDeliveryTime'?: string | null;
}


export interface CreateOrderClientPayloadOrderItemsInner {
    'vendorProductId': string;
    'quantity': number;
    'instructions'?: string | null;
    'replacementIds'?: Array<string>;
}
export interface CreateOrderPayload {
    'vendorId': string;
    'paymentMethod': PaymentMethods;
    /**
     * ID of an existing delivery address. Required if newShippingAddress is not provided for a delivery order.
     */
    'shippingAddressId'?: string | null;
    'newShippingAddress'?: CreateDeliveryAddressPayload;
    'deliveryInstructions'?: string | null;
    'orderItems': Array<OrderItemPayload>;
    'shoppingMethod': ShoppingMethod;
    'deliveryMethod': DeliveryMethod;
    /**
     * Optional. The UTC time when shopping should begin. Must be within vendor\'s operating hours.
     */
    'scheduledShoppingStartTime'?: string | null;
}


export interface CreateProductPayload {
    'barcode': string;
    'name': string;
    'description'?: string | null;
    'images'?: Array<string>;
    'attributes'?: { [key: string]: any; } | null;
    'meta'?: { [key: string]: any; } | null;
    /**
     * Array of category IDs to associate with the product.
     */
    'categoryIds': Array<string>;
    /**
     * Array of tag IDs to associate with the product.
     */
    'tagIds'?: Array<string> | null;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
}
/**
 * When creating a rating, either `ratedVendorId` or `ratedUserId` must be provided depending on the `type`.
 */
export interface CreateRatingPayload {
    /**
     * The ID of the order being rated.
     */
    'orderId': string;
    /**
     * The rating score from 1 to 5.
     */
    'rating': number;
    /**
     * An optional comment for the rating.
     */
    'comment'?: string | null;
    'type': RatingType;
    /**
     * Required if type is VENDOR.
     */
    'ratedVendorId'?: string;
    /**
     * Required if type is SHOPPER or DELIVERER.
     */
    'ratedUserId'?: string;
}


export interface CreateSupportTicketPayload {
    'title': string;
    'description': string;
    'category': TicketCategory;
    /**
     * Optional. e.g., { \"orderId\": \"uuid-goes-here\" }
     */
    'meta'?: object | null;
}


export interface CreateTagPayload {
    /**
     * The name for the new tag.
     */
    'name': string;
}
export interface CreateTagsBulkPayload {
    /**
     * A list of names for the tags to be created.
     */
    'names': Array<string>;
}
export interface CreateVendorPayload {
    'name': string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'image'?: string | null;
    'address'?: string | null;
    'longitude'?: number | null;
    'latitude'?: number | null;
    'meta'?: { [key: string]: any; } | null;
}
export interface CreateVendorProductPayload {
    'vendorId': string;
    'productId': string;
    'price': number;
    'discountedPrice'?: number | null;
    'sku'?: string | null;
    /**
     * Array of image URLs or base64 encoded strings.
     */
    'images'?: Array<string>;
    'stock'?: number | null;
    'isAvailable'?: boolean;
    'attributes'?: { [key: string]: any; };
    /**
     * The name for the vendor-specific product, which can override the base product name.
     */
    'name': string;
    'description'?: string | null;
    'categoryIds': Array<string>;
    'tagIds'?: Array<string> | null;
}
export interface CreateVendorProductWithBarcodePayload {
    'vendorId': string;
    'barcode': string;
    'price': number;
    'name': string;
    'description'?: string | null;
    'categoryIds': Array<string>;
    'discountedPrice'?: number | null;
    'sku'?: string | null;
    /**
     * Array of image URLs or base64 encoded strings.
     */
    'images'?: Array<string>;
    'stock'?: number | null;
    'isAvailable'?: boolean;
    'attributes'?: { [key: string]: any; };
    'tagIds'?: Array<string> | null;
}
export interface CreateWishlistItemPayload {
    /**
     * The ID of the vendor product to add to the wishlist.
     */
    'vendorProductId': string;
}
export interface CustomersAdminOverviewGet200Response {
    'totalCustomers'?: number;
    'totalCompletedOrders'?: number;
    'newCustomers'?: number;
}

export const Days = {
    Monday: 'monday',
    Tuesday: 'tuesday',
    Wednesday: 'wednesday',
    Thursday: 'thursday',
    Friday: 'friday',
    Saturday: 'saturday',
    Sunday: 'sunday'
} as const;

export type Days = typeof Days[keyof typeof Days];



export const DaysEnum = {
    Monday: 'monday',
    Tuesday: 'tuesday',
    Wednesday: 'wednesday',
    Thursday: 'thursday',
    Friday: 'friday',
    Saturday: 'saturday',
    Sunday: 'sunday'
} as const;

export type DaysEnum = typeof DaysEnum[keyof typeof DaysEnum];


export interface DeclineOrderPayload {
    /**
     * Reason for declining the order.
     */
    'reason'?: string | null;
}
export interface DeliveryAddress {
    'id'?: string;
    'userId'?: string;
    'addressLine1'?: string;
    'addressLine2'?: string | null;
    'city'?: string;
    'state'?: string | null;
    'postalCode'?: string | null;
    'country'?: string;
    'isDefault'?: boolean;
    'latitude'?: number | null;
    'longitude'?: number | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'label'?: string | null;
}

export const DeliveryMethod = {
    DeliveryPerson: 'delivery_person',
    CustomerPickup: 'customer_pickup'
} as const;

export type DeliveryMethod = typeof DeliveryMethod[keyof typeof DeliveryMethod];


/**
 * A single geographic point in a delivery path.
 */
export interface DeliveryPathPoint {
    'latitude'?: number;
    'longitude'?: number;
    'createdAt'?: string;
}
export interface DeliveryPersonLocation {
    /**
     * CUID
     */
    'id'?: string;
    'orderId'?: string;
    'latitude'?: number;
    'longitude'?: number;
    'createdAt'?: string;
}
export interface DeliveryPersonsAdminOverviewGet200Response {
    'totalDeliveryPersons'?: number;
    'newDeliveryPersons'?: number;
    'totalDeliveries'?: number;
    'totalReturns'?: number;
}
export interface DeliverySlot {
    'date'?: string;
    'timeSlots'?: Array<string>;
}
export interface Device {
    /**
     * CUID
     */
    'id'?: string;
    'userId'?: string;
    'fcmToken'?: string;
    'platform'?: DevicePlatformEnum;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const DevicePlatformEnum = {
    Ios: 'ios',
    Android: 'android',
    Web: 'web'
} as const;

export type DevicePlatformEnum = typeof DevicePlatformEnum[keyof typeof DevicePlatformEnum];

export interface DevicesPostRequest {
    /**
     * The Firebase Cloud Messaging token for the device.
     */
    'fcmToken': string;
    /**
     * The platform of the device.
     */
    'platform': DevicesPostRequestPlatformEnum;
}

export const DevicesPostRequestPlatformEnum = {
    Ios: 'ios',
    Android: 'android',
    Web: 'web'
} as const;

export type DevicesPostRequestPlatformEnum = typeof DevicesPostRequestPlatformEnum[keyof typeof DevicesPostRequestPlatformEnum];

export interface EarningsTotalGet200Response {
    'totalEarnings'?: number;
}
export interface Faq {
    'id'?: string;
    'question'?: string;
    'answer'?: string;
    'isActive'?: boolean;
    'sortOrder'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface Fee {
    'id'?: string;
    'type'?: FeeType;
    'amount'?: number;
    'description'?: string | null;
    'isActive'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'method'?: FeeCalculationMethod;
    /**
     * e.g., \'km\' for per_distance
     */
    'unit'?: string | null;
    'minThreshold'?: number | null;
    'maxThreshold'?: number | null;
    /**
     * e.g., \'order_subtotal\'
     */
    'thresholdAppliesTo'?: string | null;
}



export const FeeCalculationMethod = {
    Flat: 'flat',
    Percentage: 'percentage',
    PerUnit: 'per_unit',
    PerDistance: 'per_distance'
} as const;

export type FeeCalculationMethod = typeof FeeCalculationMethod[keyof typeof FeeCalculationMethod];



export const FeeType = {
    Delivery: 'delivery',
    Service: 'service',
    Shopping: 'shopping'
} as const;

export type FeeType = typeof FeeType[keyof typeof FeeType];


export interface GeneralSearchResult {
    'products'?: Array<Product>;
    'vendors'?: Array<Vendor>;
    'categories'?: Array<Category>;
}
/**
 * @type GeneralSearchStoreProductsStoreIdGet200Response
 */
export type GeneralSearchStoreProductsStoreIdGet200Response = Array<GeneralSearchStoreProductsStoreIdGet200ResponseOneOfInner> | Array<VendorProduct>;

export interface GeneralSearchStoreProductsStoreIdGet200ResponseOneOfInner {
    'id'?: string;
    'name'?: string;
    'imageUrl'?: string | null;
    'description'?: string | null;
    'products'?: Array<VendorProduct>;
}
export interface HealthGet200Response {
    'message'?: string;
}
export interface InitiateLogin {
    'mobileNumber': string;
    'role': InitiateLoginRoleEnum;
}

export const InitiateLoginRoleEnum = {
    Customer: 'CUSTOMER',
    VendorAdmin: 'VENDOR_ADMIN',
    ShopperStaff: 'SHOPPER_STAFF'
} as const;

export type InitiateLoginRoleEnum = typeof InitiateLoginRoleEnum[keyof typeof InitiateLoginRoleEnum];

export interface MediaUploadPost201Response {
    'message'?: string;
    'data'?: Media;
}
export interface Message {
    'id'?: string;
    'content'?: string;
    'senderId'?: string;
    'recipientId'?: string;
    'orderId'?: string;
    'readAt'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface MessageWithRelations {
    'id'?: string;
    'content'?: string;
    'senderId'?: string;
    'recipientId'?: string;
    'orderId'?: string;
    'readAt'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'sender'?: UserSummary;
    'recipient'?: UserSummary;
}
export interface Notification {
    /**
     * CUID
     */
    'id'?: string;
    'userId'?: string;
    'type'?: NotificationType;
    'title'?: string;
    'body'?: string;
    'isRead'?: boolean;
    /**
     * To store related IDs like orderId, etc. for deep linking
     */
    'meta'?: { [key: string]: any; } | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}



export const NotificationType = {
    OrderAccepted: 'ORDER_ACCEPTED',
    OrderDeclined: 'ORDER_DECLINED',
    OrderShoppingStarted: 'ORDER_SHOPPING_STARTED',
    OrderReadyForPickup: 'ORDER_READY_FOR_PICKUP',
    OrderReadyForDelivery: 'ORDER_READY_FOR_DELIVERY',
    EnRoute: 'EN_ROUTE',
    Delivered: 'DELIVERED',
    Completed: 'COMPLETED',
    OrderCancelled: 'ORDER_CANCELLED',
    NewOrderPlaced: 'NEW_ORDER_PLACED',
    OrderPlacedCustomer: 'ORDER_PLACED_CUSTOMER',
    AssignedToOrder: 'ASSIGNED_TO_ORDER',
    NewMessage: 'NEW_MESSAGE',
    Promotional: 'PROMOTIONAL',
    AccountUpdate: 'ACCOUNT_UPDATE',
    BugReportReceived: 'BUG_REPORT_RECEIVED',
    BugReportResolved: 'BUG_REPORT_RESOLVED'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


export interface NotificationsReadAllPatch200Response {
    'count'?: number;
}
export interface Order {
    'id'?: string;
    'userId'?: string;
    'vendorId'?: string;
    'totalAmount'?: number;
    'deliveryFee'?: number | null;
    'serviceFee'?: number | null;
    'shoppingFee'?: number | null;
    'paymentMethod'?: PaymentMethods;
    'paymentStatus'?: OrderPaymentStatusEnum;
    'orderStatus'?: OrderStatus;
    'deliveryAddressId'?: string | null;
    'deliveryInstructions'?: string | null;
    'shoppingMethod'?: ShoppingMethod;
    'deliveryMethod'?: DeliveryMethod;
    'scheduledShoppingStartTime'?: string | null;
    'shoppingHandlerId'?: string | null;
    'deliveryPersonId'?: string | null;
    'reasonForDecline'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'orderItems'?: Array<CartItem>;
    'user'?: User;
    'vendor'?: Vendor;
    'deliveryAddress'?: DeliveryAddress;
    'shopper'?: User;
    'deliverer'?: User;
}

export const OrderPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed'
} as const;

export type OrderPaymentStatusEnum = typeof OrderPaymentStatusEnum[keyof typeof OrderPaymentStatusEnum];

export interface OrderAdminOverviewGet200Response {
    'totalOrders'?: number;
    'totalProductsOrdered'?: number;
    'totalCancelledOrders'?: number;
}
export interface OrderIdVerifyPickupPostRequest {
    /**
     * The 6-digit pickup OTP.
     */
    'otp': string;
}
export interface OrderItem {
    'id'?: string;
    'orderId'?: string;
    'vendorProductId'?: string;
    'quantity'?: number;
    'instructions'?: string | null;
    'status'?: OrderItemStatus;
    'quantityFound'?: number | null;
    'chosenReplacementId'?: string | null;
    'isReplacementApproved'?: boolean | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}


export interface OrderItemPayload {
    'vendorProductId': string;
    'quantity': number;
}

export const OrderItemStatus = {
    Pending: 'PENDING',
    Found: 'FOUND',
    NotFound: 'NOT_FOUND',
    Replaced: 'REPLACED'
} as const;

export type OrderItemStatus = typeof OrderItemStatus[keyof typeof OrderItemStatus];


export interface OrderItemWithRelations {
    'id'?: string;
    'orderId'?: string;
    'vendorProductId'?: string;
    'quantity'?: number;
    'instructions'?: string | null;
    'status'?: OrderItemStatus;
    'quantityFound'?: number | null;
    'chosenReplacementId'?: string | null;
    'isReplacementApproved'?: boolean | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'vendorProduct'?: VendorProductWithProduct;
    'chosenReplacement'?: VendorProductWithProduct;
    'replacements'?: Array<VendorProductWithProduct>;
}


export interface OrderOrderIdMessagesPostRequest {
    /**
     * The ID of the user who is the recipient of the message.
     */
    'recipientId': string;
    /**
     * The text content of the message.
     */
    'content': string;
}
export interface OrderOrderIdMessagesReadPatch200Response {
    /**
     * The number of messages updated.
     */
    'count'?: number;
}

export const OrderStatus = {
    Pending: 'pending',
    AcceptedForShopping: 'accepted_for_shopping',
    CurrentlyShopping: 'currently_shopping',
    ReadyForPickup: 'ready_for_pickup',
    ReadyForDelivery: 'ready_for_delivery',
    AcceptedForDelivery: 'accepted_for_delivery',
    EnRoute: 'en_route',
    Delivered: 'delivered',
    PickedUpByCustomer: 'picked_up_by_customer',
    DeclinedByVendor: 'declined_by_vendor',
    CancelledByCustomer: 'cancelled_by_customer'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


export interface OrdersOrderIdDeliveryLocationPostRequest {
    /**
     * The latitude of the delivery person.
     */
    'latitude': number;
    /**
     * The longitude of the delivery person.
     */
    'longitude': number;
}
export interface PaginatedNotifications {
    'page'?: number;
    'totalPages'?: number;
    'pageSize'?: number;
    'totalCount'?: number;
    'data'?: Array<Notification>;
}
export interface PaginatedSupportTickets {
    'data'?: Array<SupportTicket>;
    'totalCount'?: number;
    'totalPages'?: number;
}
export interface PaginatedUsers {
    'page'?: number;
    'totalPages'?: number;
    'pageSize'?: number;
    'totalCount'?: number;
    'data'?: Array<User>;
}
export interface PaginatedVendorProducts {
    'page'?: number;
    'totalPages'?: number;
    'pageSize'?: number;
    'totalCount'?: number;
    'data'?: Array<VendorProductWithRelations>;
}
export interface PaginatedVendors {
    'page'?: number;
    'totalPages'?: number;
    'pageSize'?: number;
    'totalCount'?: number;
    'data'?: Array<VendorListItem>;
}

export const PaymentMethods = {
    CreditCard: 'credit_card',
    Wallet: 'wallet',
    Cash: 'cash'
} as const;

export type PaymentMethods = typeof PaymentMethods[keyof typeof PaymentMethods];



export const PaymentStatus = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed',
    Refunded: 'refunded'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


export interface Product {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'barcode'?: string | null;
    'imageUrl'?: string | null;
    'images'?: Array<string>;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'attributes'?: object | null;
    'meta'?: object | null;
    'categoryIds'?: Array<string>;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface ProductIdStatusPatchRequest {
    /**
     * Set to `false` to disable the product, `true` to enable it.
     */
    'isActive': boolean;
}
export interface ProductOverview {
    /**
     * The total number of base products in the system.
     */
    'totalProducts'?: number;
    /**
     * The total number of unique product listings across all vendors.
     */
    'totalVendorProducts'?: number;
}
export interface ProductVendorMyProductsGet200Response {
    'page'?: number;
    'totalPages'?: number;
    'pageSize'?: number;
    'totalCount'?: number;
    'data'?: Array<VendorProductWithRelations>;
}
export interface ProductVendorTransferPost200Response {
    'successfulTransfers'?: number;
    'skippedTransfers'?: number;
    'details'?: Array<ProductVendorTransferPost200ResponseDetailsInner>;
}
export interface ProductVendorTransferPost200ResponseDetailsInner {
    'sourceVendorProductId'?: string;
    /**
     * List of store IDs the product was successfully transferred to.
     */
    'transferredTo'?: Array<string>;
    /**
     * List of store IDs where the product already existed.
     */
    'skippedFor'?: Array<string>;
}
export interface ProductVendorTransferPostRequest {
    /**
     * An array of vendor product IDs to copy.
     */
    'sourceVendorProductIds': Array<string>;
    /**
     * An array of store IDs to copy the product to.
     */
    'targetVendorIds': Array<string>;
}
export interface ProductWithRelations {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'barcode'?: string | null;
    'imageUrl'?: string | null;
    'images'?: Array<string>;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'attributes'?: object | null;
    'meta'?: object | null;
    'categoryIds'?: Array<string>;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'categories'?: Array<CategorySummary>;
    'tags'?: Array<TagSummary>;
}
export interface Rating {
    'id'?: string;
    'orderId'?: string;
    'raterId'?: string;
    'ratedVendorId'?: string | null;
    'ratedUserId'?: string | null;
    'rating'?: number;
    'comment'?: string | null;
    'type'?: RatingType;
    'createdAt'?: string;
    'updatedAt'?: string;
}



export const RatingType = {
    Vendor: 'VENDOR',
    Shopper: 'SHOPPER',
    Deliverer: 'DELIVERER'
} as const;

export type RatingType = typeof RatingType[keyof typeof RatingType];


export interface RatingWithRelations {
    'id'?: string;
    'orderId'?: string;
    'raterId'?: string;
    'ratedVendorId'?: string | null;
    'ratedUserId'?: string | null;
    'rating'?: number;
    'comment'?: string | null;
    'type'?: RatingType;
    'createdAt'?: string;
    'updatedAt'?: string;
    'rater'?: object;
    'ratedUser'?: UserSummary;
    'ratedVendor'?: VendorSummary;
}


export interface RatingsAggregateGet200Response {
    /**
     * The average rating score.
     */
    'average'?: number;
    /**
     * The total number of ratings.
     */
    'count'?: number;
}
export interface RespondToReplacementPayload {
    'approved': boolean;
}

export const Role = {
    Customer: 'customer',
    Vendor: 'vendor',
    StoreAdmin: 'store_admin',
    StoreShopper: 'store_shopper',
    DeliveryPerson: 'delivery_person',
    Admin: 'admin'
} as const;

export type Role = typeof Role[keyof typeof Role];


export interface SavedPaymentMethod {
    'id'?: string;
    'userId'?: string;
    'stripePaymentMethodId'?: string;
    'cardBrand'?: string;
    'cardLast4'?: string;
    'isDefault'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const ShoppingMethod = {
    Vendor: 'vendor',
    DeliveryPerson: 'delivery_person'
} as const;

export type ShoppingMethod = typeof ShoppingMethod[keyof typeof ShoppingMethod];


export interface StaffPostRequest {
    'name': string;
    'email': string;
    'mobileNumber': string;
    /**
     * The ID of the store this staff belongs to.
     */
    'vendorId': string;
}
export interface StaffStaffIdPatchRequest {
    'name'?: string;
    'email'?: string;
    'mobileNumber'?: string;
    /**
     * Use to deactivate/reactivate account
     */
    'active'?: boolean;
}
export interface StoreWithLimitedProducts {
    'store'?: Vendor;
    'products'?: Array<VendorProduct>;
    /**
     * The total number of products found in the store that match the search criteria.
     */
    'totalProducts'?: number;
}
export interface StoreWithProducts {
    'vendor'?: VendorWithExtras;
    /**
     * A sample of products from the store that match the search criteria (if applicable).
     */
    'products'?: Array<VendorProduct>;
    /**
     * The total number of products in the store that match the search criteria (if applicable).
     */
    'totalProducts'?: number;
}
export interface StoresByProductResult {
    'stores'?: Array<StoreWithProducts>;
}
export interface SupportAdminOverviewGet200Response {
    'totalTickets'?: number;
    'openTickets'?: number;
    'closedTickets'?: number;
}
export interface SupportTicket {
    'id'?: string;
    'userId'?: string;
    'title'?: string;
    'description'?: string;
    'category'?: TicketCategory;
    'status'?: TicketStatus;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}


export interface Tag {
    'id'?: string;
    'name'?: string;
}
export interface TagSummary {
    'id'?: string;
    'name'?: string;
}

export const TicketCategory = {
    BugReport: 'BUG_REPORT',
    FeatureRequest: 'FEATURE_REQUEST',
    OrderIssue: 'ORDER_ISSUE',
    PaymentIssue: 'PAYMENT_ISSUE',
    AccountIssue: 'ACCOUNT_ISSUE',
    Other: 'OTHER'
} as const;

export type TicketCategory = typeof TicketCategory[keyof typeof TicketCategory];



export const TicketStatus = {
    Open: 'OPEN',
    InProgress: 'IN_PROGRESS',
    Resolved: 'RESOLVED',
    Closed: 'CLOSED'
} as const;

export type TicketStatus = typeof TicketStatus[keyof typeof TicketStatus];


export interface Transaction {
    'id'?: string;
    'userId'?: string;
    'amount'?: number;
    'type'?: TransactionType;
    'source'?: TransactionSource;
    'status'?: TransactionStatus;
    'description'?: string | null;
    'orderId'?: string;
    /**
     * ID from the external payment provider (e.g., Stripe Payment Intent ID).
     */
    'externalId'?: string | null;
    /**
     * Additional metadata, such as payment details from Stripe.
     */
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface TransactionWithRelations {
    'id'?: string;
    'userId'?: string;
    'amount'?: number;
    'type'?: TransactionType;
    'source'?: TransactionSource;
    'status'?: TransactionStatus;
    'description'?: string | null;
    'orderId'?: string;
    /**
     * ID from the external payment provider (e.g., Stripe Payment Intent ID).
     */
    'externalId'?: string | null;
    /**
     * Additional metadata, such as payment details from Stripe.
     */
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'order'?: TransactionWithRelationsAllOfOrder;
}
export interface TransactionWithRelationsAllOfOrder {
    'id'?: string;
    'orderCode'?: string;
    'totalAmount'?: number;
}
export interface TransactionsAdminOverviewGet200Response {
    'totalTransactions'?: number;
    'totalIncome'?: number;
    'totalExpense'?: number;
    'revenue'?: number;
}
export interface TransactionsCreatePaymentIntentPost200Response {
    'clientSecret'?: string;
}
export interface TransactionsCreatePaymentIntentPostRequest {
    'orderId': string;
}
export interface UpdateCartItemPayload {
    /**
     * Set to 0 to remove the item from the cart.
     */
    'quantity': number;
}
export interface UpdateCategoryPayload {
    'name'?: string;
    'parentId'?: string | null;
    'type'?: UpdateCategoryPayloadTypeEnum;
    'imageUrl'?: string | null;
}

export const UpdateCategoryPayloadTypeEnum = {
    Product: 'PRODUCT',
    Service: 'SERVICE'
} as const;

export type UpdateCategoryPayloadTypeEnum = typeof UpdateCategoryPayloadTypeEnum[keyof typeof UpdateCategoryPayloadTypeEnum];

export interface UpdateContentPayload {
    /**
     * The HTML content string.
     */
    'content': string;
}
export interface UpdateDeliveryAddressPayload {
    'addressLine1'?: string;
    'addressLine2'?: string | null;
    'city'?: string;
    'state'?: string | null;
    'postalCode'?: string | null;
    'country'?: string;
    'isDefault'?: boolean;
    'latitude'?: number | null;
    'longitude'?: number | null;
    'label'?: string | null;
}
export interface UpdateFaqPayload {
    'question'?: string;
    'answer'?: string;
    'isActive'?: boolean;
    'sortOrder'?: number;
}
export interface UpdateFeePayload {
    'amount'?: number;
    'description'?: string | null;
    'isActive'?: boolean;
    'method'?: FeeCalculationMethod;
    'unit'?: string | null;
    'minThreshold'?: number | null;
    'maxThreshold'?: number | null;
    'thresholdAppliesTo'?: string | null;
}


export interface UpdateOpeningHoursPayload {
    /**
     * The ID of the vendor whose opening hours are being updated.
     */
    'vendorId': string;
    'day': Days;
    /**
     * The opening time in 24-hour format (e.g., \'09:00\'). Set to null to mark as closed.
     */
    'open'?: string | null;
    /**
     * The closing time in 24-hour format (e.g., \'18:00\'). Set to null to mark as closed.
     */
    'close'?: string | null;
}


export interface UpdateOrderItemShoppingStatusPayload {
    'status': OrderItemStatus;
    /**
     * Required if status is FOUND.
     */
    'quantityFound'?: number;
    /**
     * The vendorProductId of the suggested replacement if status is NOT_FOUND.
     */
    'chosenReplacementId'?: string;
}


export interface UpdateOrderPayload {
    'totalAmount'?: number;
    'deliveryFee'?: number;
    'serviceFee'?: number;
    'shoppingFee'?: number;
    'paymentMethod'?: PaymentMethods;
    'paymentStatus'?: UpdateOrderPayloadPaymentStatusEnum;
    'orderStatus'?: OrderStatus;
    'deliveryAddressId'?: string;
    'deliveryInstructions'?: string;
    'shoppingHandlerId'?: string;
    'deliveryPersonId'?: string;
    'shoppingMethod'?: ShoppingMethod;
    'deliveryMethod'?: DeliveryMethod;
    'scheduledShoppingStartTime'?: string;
}

export const UpdateOrderPayloadPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed'
} as const;

export type UpdateOrderPayloadPaymentStatusEnum = typeof UpdateOrderPayloadPaymentStatusEnum[keyof typeof UpdateOrderPayloadPaymentStatusEnum];

export interface UpdateOrderStatusPayload {
    'status': OrderStatus;
}


export interface UpdateProductBasePayload {
    'id'?: string;
    'name'?: string;
    'price'?: number;
    'vendorId'?: string;
    'productId'?: string;
    'description'?: string | null;
    'discountedPrice'?: number | null;
    'images'?: Array<string>;
    'isAvailable'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'attributes'?: { [key: string]: any; };
    'categoryIds'?: Array<string>;
    /**
     * The number of times this product has been ordered.
     */
    'orderCount'?: number;
    'barcode'?: string;
    'meta'?: { [key: string]: any; };
    'tagIds'?: Array<string>;
}
export interface UpdateRatingPayload {
    /**
     * The new rating score from 1 to 5.
     */
    'rating'?: number;
    /**
     * The new comment for the rating.
     */
    'comment'?: string | null;
}
export interface UpdateSupportTicketStatusPayload {
    'status': TicketStatus;
}


export interface UpdateTagPayload {
    /**
     * The new name for the tag.
     */
    'name': string;
}
export interface UpdateTipPayload {
    'shopperTip'?: number;
    'deliveryPersonTip'?: number;
}
export interface UpdateUserPayload {
    'name'?: string | null;
    'email'?: string | null;
    'mobileNumber'?: string;
    'role'?: Role;
    'mobileVerified'?: boolean;
    'active'?: boolean;
    'language'?: string | null;
    'notification'?: { [key: string]: any; } | null;
    'referralCode'?: string | null;
}


export interface UpdateVendorPayload {
    'name'?: string;
    'email'?: string;
    'tagline'?: string;
    'details'?: string;
    'image'?: string;
    'address'?: string;
    'longitude'?: number;
    'latitude'?: number;
    'isVerified'?: boolean;
    'meta'?: { [key: string]: any; };
    'availableForShopping'?: boolean;
}
export interface UpdateVendorProductPayload {
    'price'?: number;
    'discountedPrice'?: number | null;
    'sku'?: string | null;
    'images'?: Array<string>;
    'stock'?: number | null;
    'isAvailable'?: boolean;
    'attributes'?: { [key: string]: any; };
    'name'?: string;
    'description'?: string | null;
    'categoryIds'?: Array<string>;
    'tagIds'?: Array<string>;
}
export interface User {
    'id'?: string;
    'name'?: string | null;
    'email'?: string | null;
    'mobileNumber'?: string;
    'role'?: Role;
    'mobileVerified'?: boolean;
    'active'?: boolean;
    'language'?: string | null;
    'notification'?: { [key: string]: any; } | null;
    'referralCode'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'dynamicMediaUrls'?: object | null;
    'rememberToken'?: string | null;
    'stripeCustomerId'?: string | null;
    'vendorId'?: string | null;
}


export interface UserSummary {
    'id'?: string;
    'name'?: string | null;
    'mobileNumber'?: string | null;
}
export interface Vendor {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'latitude'?: number | null;
    'longitude'?: number | null;
    /**
     * Distance in kilometers from the user.
     */
    'distance'?: number;
    'rating'?: VendorRating | null;
    'image'?: string | null;
    'address'?: string | null;
    'userId'?: string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'timezone'?: string | null;
    'isVerified'?: boolean;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isPublished'?: boolean;
    'availableForShopping'?: boolean;
}
export interface VendorCategoryWithProducts {
    'category'?: Category;
    'products'?: Array<VendorProduct>;
}
export interface VendorListItem {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'latitude'?: number | null;
    'longitude'?: number | null;
    /**
     * Distance to the vendor from the user\'s location in kilometers.
     */
    'distance'?: number | null;
    'rating'?: VendorWithDetailsAllOfRating;
    'image'?: string | null;
    'address'?: string | null;
    'userId'?: string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'timezone'?: string | null;
    'isVerified'?: boolean;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isPublished'?: boolean;
    'availableForShopping'?: boolean;
    /**
     * Number of items in the user\'s cart for this vendor. Only present if user is authenticated.
     */
    'cartItemCount'?: number;
}
export interface VendorOpeningHours {
    'id'?: string;
    'day'?: Days;
    'open'?: string | null;
    'close'?: string | null;
    'vendorId'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}


export interface VendorOrder {
    'id'?: string;
    'userId'?: string;
    'vendorId'?: string;
    'totalAmount'?: number;
    'deliveryFee'?: number | null;
    'serviceFee'?: number | null;
    'shoppingFee'?: number | null;
    'paymentMethod'?: PaymentMethods;
    'paymentStatus'?: VendorOrderPaymentStatusEnum;
    'orderStatus'?: OrderStatus;
    'deliveryAddressId'?: string | null;
    'deliveryInstructions'?: string | null;
    'shoppingMethod'?: ShoppingMethod;
    'deliveryMethod'?: DeliveryMethod;
    'scheduledShoppingStartTime'?: string | null;
    'shoppingHandlerId'?: string | null;
    'deliveryPersonId'?: string | null;
    'reasonForDecline'?: string | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'orderItems'?: Array<OrderItemWithRelations>;
    'user'?: UserSummary;
    'vendor'?: VendorWithDetails;
    'deliveryAddress'?: DeliveryAddress;
    'shopper'?: UserSummary;
    'deliverer'?: User;
    /**
     * A unique, human-readable code for the order.
     */
    'orderCode'?: string;
    'deliveryPerson'?: UserSummary;
}

export const VendorOrderPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed'
} as const;

export type VendorOrderPaymentStatusEnum = typeof VendorOrderPaymentStatusEnum[keyof typeof VendorOrderPaymentStatusEnum];

export interface VendorProduct {
    'id'?: string;
    'name'?: string;
    'price'?: number;
    'vendorId'?: string;
    'productId'?: string;
    'description'?: string | null;
    'discountedPrice'?: number | null;
    'images'?: Array<string>;
    'isAvailable'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'attributes'?: object | null;
    'categoryIds'?: Array<string>;
}
export interface VendorProductWithProduct {
    'id'?: string;
    'name'?: string;
    'price'?: number;
    'vendorId'?: string;
    'productId'?: string;
    'description'?: string | null;
    'discountedPrice'?: number | null;
    'images'?: Array<string>;
    'isAvailable'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'attributes'?: object | null;
    'categoryIds'?: Array<string>;
    'product'?: Product;
    'categories'?: Array<Category>;
}
export interface VendorProductWithRelations {
    'id'?: string;
    'name'?: string;
    'price'?: number;
    'vendorId'?: string;
    'productId'?: string;
    'description'?: string | null;
    'discountedPrice'?: number | null;
    'images'?: Array<string>;
    'isAvailable'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
    'weight'?: number | null;
    'weightUnit'?: string | null;
    'isAlcohol'?: boolean;
    'isAgeRestricted'?: boolean;
    'attributes'?: object | null;
    'categoryIds'?: Array<string>;
    'product'?: Product;
    'categories'?: Array<CategorySummary>;
    'tags'?: Array<TagSummary>;
    'vendor'?: VendorSummary;
}
/**
 * Aggregate rating for the vendor.
 */
export interface VendorRating {
    /**
     * The average rating score, from 1 to 5.
     */
    'average'?: number;
    /**
     * The total number of ratings.
     */
    'count'?: number;
}
export interface VendorSummary {
    'id'?: string;
    'name'?: string;
}
export interface VendorWithDetails {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'latitude'?: number | null;
    'longitude'?: number | null;
    /**
     * Distance to the vendor from the user\'s location in kilometers.
     */
    'distance'?: number | null;
    'rating'?: VendorWithDetailsAllOfRating;
    'image'?: string | null;
    'address'?: string | null;
    'userId'?: string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'timezone'?: string | null;
    'isVerified'?: boolean;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isPublished'?: boolean;
    'availableForShopping'?: boolean;
    'user'?: User;
    'openingHours'?: Array<VendorOpeningHours>;
    /**
     * The total number of products this vendor has.
     */
    'productCount'?: number;
    /**
     * The total number of documents this vendor has uploaded.
     */
    'documentCount'?: number;
}
export interface VendorWithDetailsAllOfRating {
    'average'?: number;
    'count'?: number;
}
export interface VendorWithExtras {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'latitude'?: number | null;
    'longitude'?: number | null;
    /**
     * Distance to the vendor from the user\'s location in kilometers.
     */
    'distance'?: number;
    'rating'?: RatingsAggregateGet200Response;
    'image'?: string | null;
    'address'?: string | null;
    'userId'?: string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'timezone'?: string | null;
    'isVerified'?: boolean;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isPublished'?: boolean;
    'availableForShopping'?: boolean;
}
export interface VendorWithRatingAndDistance {
    'subtotal'?: number;
    'totalAmount'?: number;
    'deliveryFee'?: number;
    'serviceFee'?: number;
    'shoppingFee'?: number;
    'shopperTip'?: number;
    'deliveryPersonTip'?: number;
    'paymentMethod'?: PaymentMethods;
    'paymentStatus'?: PaymentStatus;
    'orderStatus'?: OrderStatus;
    'deliveryAddressId'?: string;
    'deliveryInstructions'?: string;
    'shopperId'?: string;
    'deliveryPersonId'?: string;
    'shoppingMethod'?: ShoppingMethod;
    'deliveryMethod'?: DeliveryMethod;
    'shoppingStartTime'?: string;
    'scheduledDeliveryTime'?: string;
    'actualDeliveryTime'?: string;
}


export interface VendorWithRelations {
    'id'?: string;
    'name'?: string;
    'description'?: string | null;
    'latitude'?: number | null;
    'longitude'?: number | null;
    /**
     * Distance in kilometers from the user.
     */
    'distance'?: number;
    'rating'?: VendorRating | null;
    'image'?: string | null;
    'address'?: string | null;
    'userId'?: string;
    'email'?: string | null;
    'tagline'?: string | null;
    'details'?: string | null;
    'timezone'?: string | null;
    'isVerified'?: boolean;
    'meta'?: object | null;
    'createdAt'?: string;
    'updatedAt'?: string;
    'isPublished'?: boolean;
    'availableForShopping'?: boolean;
    'user'?: User;
    'openingHours'?: Array<VendorOpeningHours>;
}
export interface VendorsIdAvailabilityPatchRequest {
    /**
     * Set to `true` to make the store available for shopping, `false` to make it unavailable.
     */
    'available': boolean;
}
export interface VendorsIncompleteSetupsGet200Response {
    'incompleteVendors'?: Array<Vendor>;
}
export interface VendorsOverviewGet200Response {
    'totalVendorUsers'?: number;
    'totalStores'?: number;
    'totalStaff'?: number;
}
export interface Verification {
    'id'?: string;
    'mobileNumber'?: string;
    'code'?: string;
    'expiresAt'?: string;
    'createdAt'?: string | null;
    'attempts'?: number | null;
}
export interface Wallet {
    'id'?: string;
    'userId'?: string;
    'balance'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface WishlistItem {
    'id'?: string;
    'userId'?: string;
    'vendorProductId'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface WishlistItemWithRelations {
    'id'?: string;
    'userId'?: string;
    'vendorProductId'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'vendorProduct'?: VendorProductWithRelations;
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adsIdDelete', 'id', id)
            const localVarPath = `/ads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdPatch: async (id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adsIdPatch', 'id', id)
            const localVarPath = `/ads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', String(isActive) as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.append('startDate', startDate as any);
            }
    
            if (endDate !== undefined) { 
                localVarFormParams.append('endDate', endDate as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsPost: async (title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('adsPost', 'title', title)
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('adsPost', 'vendorId', vendorId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('adsPost', 'image', image)
            const localVarPath = `/ads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (vendorId !== undefined) { 
                localVarFormParams.append('vendorId', vendorId as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', String(isActive) as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.append('startDate', startDate as any);
            }
    
            if (endDate !== undefined) { 
                localVarFormParams.append('endDate', endDate as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsIdStatusPatch: async (id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bugReportsIdStatusPatch', 'id', id)
            // verify required parameter 'bugReportsIdStatusPatchRequest' is not null or undefined
            assertParamExists('bugReportsIdStatusPatch', 'bugReportsIdStatusPatchRequest', bugReportsIdStatusPatchRequest)
            const localVarPath = `/bug-reports/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bugReportsIdStatusPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypePatch: async (type: ContentType, updateContentPayload: UpdateContentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contentTypePatch', 'type', type)
            // verify required parameter 'updateContentPayload' is not null or undefined
            assertParamExists('contentTypePatch', 'updateContentPayload', updateContentPayload)
            const localVarPath = `/content/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContentPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminAllGet: async (name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minAmountSpent !== undefined) {
                localVarQueryParameter['minAmountSpent'] = minAmountSpent;
            }

            if (maxAmountSpent !== undefined) {
                localVarQueryParameter['maxAmountSpent'] = maxAmountSpent;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdGet: async (customerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdGet', 'customerId', customerId)
            const localVarPath = `/customers/admin/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdPatch: async (customerId: string, updateUserPayload: UpdateUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdPatch', 'customerId', customerId)
            // verify required parameter 'updateUserPayload' is not null or undefined
            assertParamExists('customersAdminCustomerIdPatch', 'updateUserPayload', updateUserPayload)
            const localVarPath = `/customers/admin/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet: async (customerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdTransactionsGet', 'customerId', customerId)
            const localVarPath = `/customers/admin/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminOverviewGet: async (days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminAllGet: async (name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/delivery-persons/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minDeliveries !== undefined) {
                localVarQueryParameter['minDeliveries'] = minDeliveries;
            }

            if (maxDeliveries !== undefined) {
                localVarQueryParameter['maxDeliveries'] = maxDeliveries;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdDeliveriesGet: async (id: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdDeliveriesGet', 'id', id)
            const localVarPath = `/delivery-persons/admin/{id}/deliveries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdGet', 'id', id)
            const localVarPath = `/delivery-persons/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdPatch: async (id: string, updateUserPayload: UpdateUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdPatch', 'id', id)
            // verify required parameter 'updateUserPayload' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdPatch', 'updateUserPayload', updateUserPayload)
            const localVarPath = `/delivery-persons/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminOverviewGet: async (days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/delivery-persons/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminAllGet: async (orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderCode !== undefined) {
                localVarQueryParameter['orderCode'] = orderCode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAdminOrderIdMessagesGet', 'orderId', orderId)
            const localVarPath = `/order/admin/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdPatch: async (orderId: string, updateOrderPayload: UpdateOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAdminOrderIdPatch', 'orderId', orderId)
            // verify required parameter 'updateOrderPayload' is not null or undefined
            assertParamExists('orderAdminOrderIdPatch', 'updateOrderPayload', updateOrderPayload)
            const localVarPath = `/order/admin/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminAllGet: async (name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (isAlcohol !== undefined) {
                localVarQueryParameter['isAlcohol'] = isAlcohol;
            }

            if (isAgeRestricted !== undefined) {
                localVarQueryParameter['isAgeRestricted'] = isAgeRestricted;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminProductIdVendorProductsGet: async (productId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productAdminProductIdVendorProductsGet', 'productId', productId)
            const localVarPath = `/product/admin/{productId}/vendor-products`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdStatusPatch: async (id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdStatusPatch', 'id', id)
            // verify required parameter 'productIdStatusPatchRequest' is not null or undefined
            assertParamExists('productIdStatusPatch', 'productIdStatusPatchRequest', productIdStatusPatchRequest)
            const localVarPath = `/product/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productIdStatusPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStaffIdGet: async (staffId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('staffAdminStaffIdGet', 'staffId', staffId)
            const localVarPath = `/staff/admin/{staffId}`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStoreVendorIdGet: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('staffAdminStoreVendorIdGet', 'vendorId', vendorId)
            const localVarPath = `/staff/admin/store/{vendorId}`
                .replace(`{${"vendorId"}}`, encodeURIComponent(String(vendorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsGet: async (customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdStatusPatch: async (ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportTicketsTicketIdStatusPatch', 'ticketId', ticketId)
            // verify required parameter 'updateSupportTicketStatusPayload' is not null or undefined
            assertParamExists('supportTicketsTicketIdStatusPatch', 'updateSupportTicketStatusPayload', updateSupportTicketStatusPayload)
            const localVarPath = `/support/tickets/{ticketId}/status`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupportTicketStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminAllGet: async (orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderCode !== undefined) {
                localVarQueryParameter['orderCode'] = orderCode;
            }

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (status !== undefined) {
                for (const [key, value] of Object.entries(status)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdGet: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('transactionsAdminTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/transactions/admin/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdSendReceiptPost: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('transactionsAdminTransactionIdSendReceiptPost', 'transactionId', transactionId)
            const localVarPath = `/transactions/admin/{transactionId}/send-receipt`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsIdPatch(id, title, description, image, isActive, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ad>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsPost(title, vendorId, image, description, isActive, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.bugReportsIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.categoryAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Content>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTypePatch(type, updateContentPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.contentTypePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.customersAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdGet(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.customersAdminCustomerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdPatch(customerId, updateUserPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.customersAdminCustomerIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdTransactionsGet(customerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.customersAdminCustomerIdTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomersAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminOverviewGet(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.customersAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deliveryPersonsAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdDeliveriesGet(id, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deliveryPersonsAdminIdDeliveriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deliveryPersonsAdminIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdPatch(id, updateUserPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deliveryPersonsAdminIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryPersonsAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminOverviewGet(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deliveryPersonsAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.orderAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOrderIdMessagesGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.orderAdminOrderIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOrderIdPatch(orderId, updateOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.orderAdminOrderIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.orderAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.productAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.productAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminProductIdVendorProductsGet(productId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.productAdminProductIdVendorProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdStatusPatch(id, productIdStatusPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.productIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffAdminStaffIdGet(staffId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.staffAdminStaffIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffAdminStoreVendorIdGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.staffAdminStoreVendorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.supportAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupportTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.supportTicketsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.supportTicketsTicketIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.transactionsAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.transactionsAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminTransactionIdGet(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.transactionsAdminTransactionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminTransactionIdSendReceiptPost(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.transactionsAdminTransactionIdSendReceiptPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorsOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.vendorsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adsIdPatch(id, title, description, image, isActive, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<Ad> {
            return localVarFp.adsPost(title, vendorId, image, description, isActive, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<CategoryOverview> {
            return localVarFp.categoryAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig): AxiosPromise<Content> {
            return localVarFp.contentTypePatch(type, updateContentPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdGet(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdPatch(customerId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomersAdminOverviewGet200Response> {
            return localVarFp.customersAdminOverviewGet(days, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdDeliveriesGet(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdPatch(id, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryPersonsAdminOverviewGet200Response> {
            return localVarFp.deliveryPersonsAdminOverviewGet(days, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageWithRelations>> {
            return localVarFp.orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderAdminOrderIdPatch(orderId, updateOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<OrderAdminOverviewGet200Response> {
            return localVarFp.orderAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductOverview> {
            return localVarFp.productAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productAdminProductIdVendorProductsGet(productId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productIdStatusPatch(id, productIdStatusPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffAdminStaffIdGet(staffId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffAdminStoreVendorIdGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<SupportAdminOverviewGet200Response> {
            return localVarFp.supportAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSupportTickets> {
            return localVarFp.supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig): AxiosPromise<SupportTicket> {
            return localVarFp.supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<TransactionsAdminOverviewGet200Response> {
            return localVarFp.transactionsAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionWithRelations> {
            return localVarFp.transactionsAdminTransactionIdGet(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsAdminTransactionIdSendReceiptPost(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<VendorsOverviewGet200Response> {
            return localVarFp.vendorsOverviewGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Delete an ad (Admin)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an ad (Admin)
     * @param {string} id 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {File} [image] 
     * @param {boolean} [isActive] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adsIdPatch(id, title, description, image, isActive, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new advertisement for a store. Requires admin privileges.
     * @summary Create a new ad (Admin)
     * @param {string} title 
     * @param {string} vendorId 
     * @param {File} image The ad image file.
     * @param {string} [description] 
     * @param {boolean} [isActive] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adsPost(title, vendorId, image, description, isActive, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bug report\'s status (Admin only)
     * @param {string} id The ID of the bug report to update.
     * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
     * @summary Get an overview of category data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).categoryAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
     * @summary Update static content by type (Admin)
     * @param {ContentType} type The type of content to update.
     * @param {UpdateContentPayload} updateContentPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).contentTypePatch(type, updateContentPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
     * @summary Get a paginated list of all customers (Admin)
     * @param {string} [name] Filter by customer name (case-insensitive).
     * @param {boolean} [status] Filter by active status (true/false).
     * @param {number} [minAmountSpent] Filter by minimum total amount spent.
     * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
     * @param {string} [createdAtStart] Filter customers created on or after this date.
     * @param {string} [createdAtEnd] Filter customers created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
     * @summary Get a single customer\'s details (Admin)
     * @param {string} customerId The ID of the customer to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).customersAdminCustomerIdGet(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
     * @summary Update a customer\'s profile (Admin)
     * @param {string} customerId The ID of the customer to update.
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).customersAdminCustomerIdPatch(customerId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
     * @summary Get a paginated list of a customer\'s transactions (Admin)
     * @param {string} customerId The ID of the customer.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
     * @summary Get platform-wide customer overview data (Admin)
     * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).customersAdminOverviewGet(days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
     * @summary Get a paginated list of all delivery persons (Admin)
     * @param {string} [name] Filter by name (case-insensitive).
     * @param {boolean} [status] Filter by active status (true/false).
     * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
     * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
     * @param {string} [createdAtStart] Filter users created on or after this date.
     * @param {string} [createdAtEnd] Filter users created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all completed deliveries for a specific delivery person.
     * @summary Get a paginated delivery history for a single delivery person (Admin)
     * @param {string} id The ID of the delivery person.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deliveryPersonsAdminIdDeliveriesGet(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
     * @summary Get a single delivery person\'s details (Admin)
     * @param {string} id The ID of the delivery person to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deliveryPersonsAdminIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
     * @summary Update a delivery person\'s profile (Admin)
     * @param {string} id The ID of the delivery person to update.
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deliveryPersonsAdminIdPatch(id, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
     * @summary Get platform-wide delivery person overview data (Admin)
     * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deliveryPersonsAdminOverviewGet(days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
     * @summary Get a paginated list of all orders (Admin)
     * @param {string} [orderCode] Filter by order code.
     * @param {OrderStatus} [status] Filter by order status.
     * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
     * @param {string} [createdAtStart] Filter orders created on or after this date.
     * @param {string} [createdAtEnd] Filter orders created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the complete conversation history for a specific order. Only accessible by admins.
     * @summary Get all messages for an order (Admin)
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
     * @summary Update an order\'s details (Admin)
     * @param {string} orderId The ID of the order to update.
     * @param {UpdateOrderPayload} updateOrderPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).orderAdminOrderIdPatch(orderId, updateOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
     * @summary Get platform-wide order overview data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).orderAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
     * @summary Get all base products with filtering and pagination (Admin)
     * @param {string} [name] Filter by product name (case-insensitive contains).
     * @param {string} [categoryId] Filter by a specific category ID.
     * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
     * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
     * @summary Get an overview of product data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).productAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
     * @summary Get all vendor products for a specific base product (Admin)
     * @param {string} productId The ID of the base product.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).productAdminProductIdVendorProductsGet(productId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to enable or disable a base product by setting its `isActive` flag.
     * @summary Update a base product\'s active status (Admin)
     * @param {string} id The ID of the base product to update.
     * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).productIdStatusPatch(id, productIdStatusPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
     * @summary Get a single staff member by ID (Admin)
     * @param {string} staffId The user ID of the staff member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).staffAdminStaffIdGet(staffId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
     * @summary List all staff for a specific store (Admin)
     * @param {string} vendorId The ID of the store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).staffAdminStoreVendorIdGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
     * @summary Get platform-wide support ticket overview (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).supportAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all support tickets. Requires admin privileges.
     * @summary Get all support tickets (Admin)
     * @param {string} [customerName] Filter by customer name (case-insensitive).
     * @param {TicketStatus} [status] Filter by ticket status.
     * @param {string} [createdAtStart] Filter tickets created on or after this date.
     * @param {string} [createdAtEnd] Filter tickets created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of a specific support ticket. Requires admin privileges.
     * @summary Update a support ticket\'s status (Admin)
     * @param {string} ticketId 
     * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
     * @summary Get a paginated list of all transactions (Admin)
     * @param {string} [orderCode] Filter by order code.
     * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
     * @param {TransactionStatus} [status] Filter by transaction status.
     * @param {string} [createdAtStart] Filter transactions created on or after this date.
     * @param {string} [createdAtEnd] Filter transactions created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
     * @summary Get platform-wide transaction overview (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).transactionsAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
     * @summary Get a single transaction by ID (Admin)
     * @param {string} transactionId The ID of the transaction to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).transactionsAdminTransactionIdGet(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
     * @summary Generate and send a receipt for a transaction (Admin)
     * @param {string} transactionId The ID of the transaction to send a receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).transactionsAdminTransactionIdSendReceiptPost(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
     * @summary Get platform overview data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsOverviewGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).vendorsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdsApi - axios parameter creator
 */
export const AdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of ads. Publicly accessible to get active ads. Admins can filter by status.
         * @summary Get a list of ads
         * @param {boolean} [isActive] Filter by active status. If true, only returns currently running ads.
         * @param {string} [vendorId] Filter ads for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsGet: async (isActive?: boolean, vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adsIdDelete', 'id', id)
            const localVarPath = `/ads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single ad by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adsIdGet', 'id', id)
            const localVarPath = `/ads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdPatch: async (id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adsIdPatch', 'id', id)
            const localVarPath = `/ads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', String(isActive) as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.append('startDate', startDate as any);
            }
    
            if (endDate !== undefined) { 
                localVarFormParams.append('endDate', endDate as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsPost: async (title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('adsPost', 'title', title)
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('adsPost', 'vendorId', vendorId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('adsPost', 'image', image)
            const localVarPath = `/ads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (vendorId !== undefined) { 
                localVarFormParams.append('vendorId', vendorId as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', String(isActive) as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.append('startDate', startDate as any);
            }
    
            if (endDate !== undefined) { 
                localVarFormParams.append('endDate', endDate as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdsApi - functional programming interface
 */
export const AdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of ads. Publicly accessible to get active ads. Admins can filter by status.
         * @summary Get a list of ads
         * @param {boolean} [isActive] Filter by active status. If true, only returns currently running ads.
         * @param {string} [vendorId] Filter ads for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsGet(isActive?: boolean, vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ad>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsGet(isActive, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single ad by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ad>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsIdPatch(id, title, description, image, isActive, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ad>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsPost(title, vendorId, image, description, isActive, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdsApi - factory interface
 */
export const AdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdsApiFp(configuration)
    return {
        /**
         * Retrieves a list of ads. Publicly accessible to get active ads. Admins can filter by status.
         * @summary Get a list of ads
         * @param {boolean} [isActive] Filter by active status. If true, only returns currently running ads.
         * @param {string} [vendorId] Filter ads for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsGet(isActive?: boolean, vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Ad>> {
            return localVarFp.adsGet(isActive, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an ad (Admin)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single ad by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Ad> {
            return localVarFp.adsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an ad (Admin)
         * @param {string} id 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {File} [image] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adsIdPatch(id, title, description, image, isActive, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new advertisement for a store. Requires admin privileges.
         * @summary Create a new ad (Admin)
         * @param {string} title 
         * @param {string} vendorId 
         * @param {File} image The ad image file.
         * @param {string} [description] 
         * @param {boolean} [isActive] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<Ad> {
            return localVarFp.adsPost(title, vendorId, image, description, isActive, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdsApi - object-oriented interface
 */
export class AdsApi extends BaseAPI {
    /**
     * Retrieves a list of ads. Publicly accessible to get active ads. Admins can filter by status.
     * @summary Get a list of ads
     * @param {boolean} [isActive] Filter by active status. If true, only returns currently running ads.
     * @param {string} [vendorId] Filter ads for a specific store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsGet(isActive?: boolean, vendorId?: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsGet(isActive, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an ad (Admin)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single ad by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an ad (Admin)
     * @param {string} id 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {File} [image] 
     * @param {boolean} [isActive] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsIdPatch(id: string, title?: string, description?: string, image?: File, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsIdPatch(id, title, description, image, isActive, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new advertisement for a store. Requires admin privileges.
     * @summary Create a new ad (Admin)
     * @param {string} title 
     * @param {string} vendorId 
     * @param {File} image The ad image file.
     * @param {string} [description] 
     * @param {boolean} [isActive] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adsPost(title: string, vendorId: string, image: File, description?: string, isActive?: boolean, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsPost(title, vendorId, image, description, isActive, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks if a user exists with the given mobile number and role. If they exist, a verification code is sent to their mobile number.
         * @summary Initiate user login or resend verification code
         * @param {AuthInitiateLoginPostRequest} authInitiateLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInitiateLoginPost: async (authInitiateLoginPostRequest: AuthInitiateLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authInitiateLoginPostRequest' is not null or undefined
            assertParamExists('authInitiateLoginPost', 'authInitiateLoginPostRequest', authInitiateLoginPostRequest)
            const localVarPath = `/auth/initiate-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authInitiateLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account and sends a verification code to their mobile number.
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (authRegisterPostRequest: AuthRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterPostRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'authRegisterPostRequest', authRegisterPostRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the provided code for the given mobile number and role, and returns a JWT token upon successful verification.
         * @summary Verify code and log in
         * @param {AuthVerifyLoginPostRequest} authVerifyLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyLoginPost: async (authVerifyLoginPostRequest: AuthVerifyLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyLoginPostRequest' is not null or undefined
            assertParamExists('authVerifyLoginPost', 'authVerifyLoginPostRequest', authVerifyLoginPostRequest)
            const localVarPath = `/auth/verify-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks if a user exists with the given mobile number and role. If they exist, a verification code is sent to their mobile number.
         * @summary Initiate user login or resend verification code
         * @param {AuthInitiateLoginPostRequest} authInitiateLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authInitiateLoginPost(authInitiateLoginPostRequest: AuthInitiateLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInitiateLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authInitiateLoginPost(authInitiateLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authInitiateLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account and sends a verification code to their mobile number.
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(authRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the provided code for the given mobile number and role, and returns a JWT token upon successful verification.
         * @summary Verify code and log in
         * @param {AuthVerifyLoginPostRequest} authVerifyLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyLoginPost(authVerifyLoginPostRequest: AuthVerifyLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyLoginPost(authVerifyLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Checks if a user exists with the given mobile number and role. If they exist, a verification code is sent to their mobile number.
         * @summary Initiate user login or resend verification code
         * @param {AuthInitiateLoginPostRequest} authInitiateLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInitiateLoginPost(authInitiateLoginPostRequest: AuthInitiateLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthInitiateLoginPost200Response> {
            return localVarFp.authInitiateLoginPost(authInitiateLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account and sends a verification code to their mobile number.
         * @summary Register a new user
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authRegisterPost(authRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the provided code for the given mobile number and role, and returns a JWT token upon successful verification.
         * @summary Verify code and log in
         * @param {AuthVerifyLoginPostRequest} authVerifyLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyLoginPost(authVerifyLoginPostRequest: AuthVerifyLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authVerifyLoginPost(authVerifyLoginPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Checks if a user exists with the given mobile number and role. If they exist, a verification code is sent to their mobile number.
     * @summary Initiate user login or resend verification code
     * @param {AuthInitiateLoginPostRequest} authInitiateLoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authInitiateLoginPost(authInitiateLoginPostRequest: AuthInitiateLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authInitiateLoginPost(authInitiateLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account and sends a verification code to their mobile number.
     * @summary Register a new user
     * @param {AuthRegisterPostRequest} authRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(authRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the provided code for the given mobile number and role, and returns a JWT token upon successful verification.
     * @summary Verify code and log in
     * @param {AuthVerifyLoginPostRequest} authVerifyLoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authVerifyLoginPost(authVerifyLoginPostRequest: AuthVerifyLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyLoginPost(authVerifyLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BugReportApi - axios parameter creator
 */
export const BugReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsIdStatusPatch: async (id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bugReportsIdStatusPatch', 'id', id)
            // verify required parameter 'bugReportsIdStatusPatchRequest' is not null or undefined
            assertParamExists('bugReportsIdStatusPatch', 'bugReportsIdStatusPatchRequest', bugReportsIdStatusPatchRequest)
            const localVarPath = `/bug-reports/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bugReportsIdStatusPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report a bug
         * @param {string} description A description of the bug.
         * @param {File} [image] (Optional) An image of the bug.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsPost: async (description: string, image?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'description' is not null or undefined
            assertParamExists('bugReportsPost', 'description', description)
            const localVarPath = `/bug-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugReportApi - functional programming interface
 */
export const BugReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BugReportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BugReportApi.bugReportsIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Report a bug
         * @param {string} description A description of the bug.
         * @param {File} [image] (Optional) An image of the bug.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bugReportsPost(description: string, image?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bugReportsPost(description, image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BugReportApi.bugReportsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BugReportApi - factory interface
 */
export const BugReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BugReportApiFp(configuration)
    return {
        /**
         * 
         * @summary Update a bug report\'s status (Admin only)
         * @param {string} id The ID of the bug report to update.
         * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report a bug
         * @param {string} description A description of the bug.
         * @param {File} [image] (Optional) An image of the bug.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportsPost(description: string, image?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bugReportsPost(description, image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BugReportApi - object-oriented interface
 */
export class BugReportApi extends BaseAPI {
    /**
     * 
     * @summary Update a bug report\'s status (Admin only)
     * @param {string} id The ID of the bug report to update.
     * @param {BugReportsIdStatusPatchRequest} bugReportsIdStatusPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bugReportsIdStatusPatch(id: string, bugReportsIdStatusPatchRequest: BugReportsIdStatusPatchRequest, options?: RawAxiosRequestConfig) {
        return BugReportApiFp(this.configuration).bugReportsIdStatusPatch(id, bugReportsIdStatusPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report a bug
     * @param {string} description A description of the bug.
     * @param {File} [image] (Optional) An image of the bug.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bugReportsPost(description: string, image?: File, options?: RawAxiosRequestConfig) {
        return BugReportApiFp(this.configuration).bugReportsPost(description, image, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartApi - axios parameter creator
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a cart by its ID
         * @param {string} cartId The ID of the cart to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartCartIdDelete: async (cartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('cartCartIdDelete', 'cartId', cartId)
            const localVarPath = `/cart/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific cart by its ID
         * @param {string} cartId The ID of the cart to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartCartIdGet: async (cartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('cartCartIdGet', 'cartId', cartId)
            const localVarPath = `/cart/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all carts for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a cart by its ID
         * @param {string} cartId The ID of the cart to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartCartIdDelete(cartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartCartIdDelete(cartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartCartIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific cart by its ID
         * @param {string} cartId The ID of the cart to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartCartIdGet(cartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartCartIdGet(cartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartCartIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all carts for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartApi - factory interface
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a cart by its ID
         * @param {string} cartId The ID of the cart to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartCartIdDelete(cartId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cartCartIdDelete(cartId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific cart by its ID
         * @param {string} cartId The ID of the cart to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartCartIdGet(cartId: string, options?: RawAxiosRequestConfig): AxiosPromise<Cart> {
            return localVarFp.cartCartIdGet(cartId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all carts for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Cart>> {
            return localVarFp.cartGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartApi - object-oriented interface
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Delete a cart by its ID
     * @param {string} cartId The ID of the cart to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartCartIdDelete(cartId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartCartIdDelete(cartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific cart by its ID
     * @param {string} cartId The ID of the cart to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartCartIdGet(cartId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartCartIdGet(cartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all carts for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartGet(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartItemApi - axios parameter creator
 */
export const CartItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a cart item by its ID
         * @param {string} id The ID of the cart item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartItemsIdDelete', 'id', id)
            const localVarPath = `/cart-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single cart item by its ID
         * @param {string} id The ID of the cart item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartItemsIdGet', 'id', id)
            const localVarPath = `/cart-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a cart item\'s quantity
         * @param {string} id The ID of the cart item to update.
         * @param {UpdateCartItemPayload} updateCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdPut: async (id: string, updateCartItemPayload: UpdateCartItemPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cartItemsIdPut', 'id', id)
            // verify required parameter 'updateCartItemPayload' is not null or undefined
            assertParamExists('cartItemsIdPut', 'updateCartItemPayload', updateCartItemPayload)
            const localVarPath = `/cart-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCartItemPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an item to the appropriate vendor\'s cart. If a cart for that vendor doesn\'t exist, it\'s created. If the item is already in the cart, its quantity is updated to the new value provided. 
         * @summary Add or update an item in the cart.
         * @param {AddCartItemPayload} addCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsPost: async (addCartItemPayload: AddCartItemPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCartItemPayload' is not null or undefined
            assertParamExists('cartItemsPost', 'addCartItemPayload', addCartItemPayload)
            const localVarPath = `/cart-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCartItemPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartItemApi - functional programming interface
 */
export const CartItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a cart item by its ID
         * @param {string} id The ID of the cart item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartItemWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartItemApi.cartItemsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single cart item by its ID
         * @param {string} id The ID of the cart item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartItemWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartItemApi.cartItemsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a cart item\'s quantity
         * @param {string} id The ID of the cart item to update.
         * @param {UpdateCartItemPayload} updateCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsIdPut(id: string, updateCartItemPayload: UpdateCartItemPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartItemWithProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsIdPut(id, updateCartItemPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartItemApi.cartItemsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds an item to the appropriate vendor\'s cart. If a cart for that vendor doesn\'t exist, it\'s created. If the item is already in the cart, its quantity is updated to the new value provided. 
         * @summary Add or update an item in the cart.
         * @param {AddCartItemPayload} addCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartItemsPost(addCartItemPayload: AddCartItemPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartItemsPost(addCartItemPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartItemApi.cartItemsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartItemApi - factory interface
 */
export const CartItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a cart item by its ID
         * @param {string} id The ID of the cart item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CartItemWithProduct> {
            return localVarFp.cartItemsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single cart item by its ID
         * @param {string} id The ID of the cart item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CartItemWithProduct> {
            return localVarFp.cartItemsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a cart item\'s quantity
         * @param {string} id The ID of the cart item to update.
         * @param {UpdateCartItemPayload} updateCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsIdPut(id: string, updateCartItemPayload: UpdateCartItemPayload, options?: RawAxiosRequestConfig): AxiosPromise<CartItemWithProduct> {
            return localVarFp.cartItemsIdPut(id, updateCartItemPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an item to the appropriate vendor\'s cart. If a cart for that vendor doesn\'t exist, it\'s created. If the item is already in the cart, its quantity is updated to the new value provided. 
         * @summary Add or update an item in the cart.
         * @param {AddCartItemPayload} addCartItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartItemsPost(addCartItemPayload: AddCartItemPayload, options?: RawAxiosRequestConfig): AxiosPromise<Cart> {
            return localVarFp.cartItemsPost(addCartItemPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartItemApi - object-oriented interface
 */
export class CartItemApi extends BaseAPI {
    /**
     * 
     * @summary Delete a cart item by its ID
     * @param {string} id The ID of the cart item to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartItemsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CartItemApiFp(this.configuration).cartItemsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single cart item by its ID
     * @param {string} id The ID of the cart item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartItemsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CartItemApiFp(this.configuration).cartItemsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a cart item\'s quantity
     * @param {string} id The ID of the cart item to update.
     * @param {UpdateCartItemPayload} updateCartItemPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartItemsIdPut(id: string, updateCartItemPayload: UpdateCartItemPayload, options?: RawAxiosRequestConfig) {
        return CartItemApiFp(this.configuration).cartItemsIdPut(id, updateCartItemPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an item to the appropriate vendor\'s cart. If a cart for that vendor doesn\'t exist, it\'s created. If the item is already in the cart, its quantity is updated to the new value provided. 
     * @summary Add or update an item in the cart.
     * @param {AddCartItemPayload} addCartItemPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cartItemsPost(addCartItemPayload: AddCartItemPayload, options?: RawAxiosRequestConfig) {
        return CartItemApiFp(this.configuration).cartItemsPost(addCartItemPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create multiple categories in bulk
         * @param {CreateCategoriesBulkPayload} createCategoriesBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryBulkPost: async (createCategoriesBulkPayload: CreateCategoriesBulkPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoriesBulkPayload' is not null or undefined
            assertParamExists('categoryBulkPost', 'createCategoriesBulkPayload', createCategoriesBulkPayload)
            const localVarPath = `/category/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoriesBulkPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all categories, with optional filters
         * @param {string} [parentId] Filter categories by their parent ID.
         * @param {CategoryGetTypeEnum} [type] Filter categories by their type.
         * @param {string} [name] Filter categories by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryGet: async (parentId?: string, type?: CategoryGetTypeEnum, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a category
         * @param {string} id The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryIdDelete', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a category by its ID
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryIdGet', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a category\'s details. This can be used to change its name, description, or move it within the hierarchy. - To change a sub-category\'s parent, provide a new `parentId`. - To promote a sub-category to a parent category, set `parentId` to `null`. 
         * @summary Update a category (Admin)
         * @param {string} id The ID of the category to update.
         * @param {UpdateCategoryPayload} updateCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdPut: async (id: string, updateCategoryPayload: UpdateCategoryPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('categoryIdPut', 'id', id)
            // verify required parameter 'updateCategoryPayload' is not null or undefined
            assertParamExists('categoryIdPut', 'updateCategoryPayload', updateCategoryPayload)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all top-level categories (those without a parent).
         * @summary Get all parent categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryParentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/parents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new category. To create a parent category, omit the `parentId`. To create a sub-category, provide the `parentId` of an existing category.
         * @summary Create a new category (Admin)
         * @param {CreateCategoryPayload} createCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPost: async (createCategoryPayload: CreateCategoryPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryPayload' is not null or undefined
            assertParamExists('categoryPost', 'createCategoryPayload', createCategoryPayload)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all categories that are children of another category (i.e., their parentId is not null).
         * @summary Get all sub-categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorySubCategoriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/sub-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create multiple categories in bulk
         * @param {CreateCategoriesBulkPayload} createCategoriesBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryBulkPost(createCategoriesBulkPayload: CreateCategoriesBulkPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryBulkPost(createCategoriesBulkPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryBulkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all categories, with optional filters
         * @param {string} [parentId] Filter categories by their parent ID.
         * @param {CategoryGetTypeEnum} [type] Filter categories by their type.
         * @param {string} [name] Filter categories by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryGet(parentId?: string, type?: CategoryGetTypeEnum, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryGet(parentId, type, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a category
         * @param {string} id The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a category by its ID
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a category\'s details. This can be used to change its name, description, or move it within the hierarchy. - To change a sub-category\'s parent, provide a new `parentId`. - To promote a sub-category to a parent category, set `parentId` to `null`. 
         * @summary Update a category (Admin)
         * @param {string} id The ID of the category to update.
         * @param {UpdateCategoryPayload} updateCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryIdPut(id: string, updateCategoryPayload: UpdateCategoryPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryIdPut(id, updateCategoryPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all top-level categories (those without a parent).
         * @summary Get all parent categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryParentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryParentsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryParentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new category. To create a parent category, omit the `parentId`. To create a sub-category, provide the `parentId` of an existing category.
         * @summary Create a new category (Admin)
         * @param {CreateCategoryPayload} createCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryPost(createCategoryPayload: CreateCategoryPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryPost(createCategoryPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all categories that are children of another category (i.e., their parentId is not null).
         * @summary Get all sub-categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categorySubCategoriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categorySubCategoriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categorySubCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
         * @summary Get an overview of category data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<CategoryOverview> {
            return localVarFp.categoryAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create multiple categories in bulk
         * @param {CreateCategoriesBulkPayload} createCategoriesBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryBulkPost(createCategoriesBulkPayload: CreateCategoriesBulkPayload, options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.categoryBulkPost(createCategoriesBulkPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all categories, with optional filters
         * @param {string} [parentId] Filter categories by their parent ID.
         * @param {CategoryGetTypeEnum} [type] Filter categories by their type.
         * @param {string} [name] Filter categories by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryGet(parentId?: string, type?: CategoryGetTypeEnum, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.categoryGet(parentId, type, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a category
         * @param {string} id The ID of the category to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.categoryIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a category by its ID
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.categoryIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a category\'s details. This can be used to change its name, description, or move it within the hierarchy. - To change a sub-category\'s parent, provide a new `parentId`. - To promote a sub-category to a parent category, set `parentId` to `null`. 
         * @summary Update a category (Admin)
         * @param {string} id The ID of the category to update.
         * @param {UpdateCategoryPayload} updateCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryIdPut(id: string, updateCategoryPayload: UpdateCategoryPayload, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.categoryIdPut(id, updateCategoryPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all top-level categories (those without a parent).
         * @summary Get all parent categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryParentsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.categoryParentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new category. To create a parent category, omit the `parentId`. To create a sub-category, provide the `parentId` of an existing category.
         * @summary Create a new category (Admin)
         * @param {CreateCategoryPayload} createCategoryPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPost(createCategoryPayload: CreateCategoryPayload, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.categoryPost(createCategoryPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all categories that are children of another category (i.e., their parentId is not null).
         * @summary Get all sub-categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorySubCategoriesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.categorySubCategoriesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 */
export class CategoryApi extends BaseAPI {
    /**
     * Retrieves aggregate data about categories, such as the total number of parent and sub-categories.
     * @summary Get an overview of category data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create multiple categories in bulk
     * @param {CreateCategoriesBulkPayload} createCategoriesBulkPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryBulkPost(createCategoriesBulkPayload: CreateCategoriesBulkPayload, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryBulkPost(createCategoriesBulkPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all categories, with optional filters
     * @param {string} [parentId] Filter categories by their parent ID.
     * @param {CategoryGetTypeEnum} [type] Filter categories by their type.
     * @param {string} [name] Filter categories by name (case-insensitive search).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryGet(parentId?: string, type?: CategoryGetTypeEnum, name?: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryGet(parentId, type, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a category
     * @param {string} id The ID of the category to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a category by its ID
     * @param {string} id The ID of the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryIdGet(id: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a category\'s details. This can be used to change its name, description, or move it within the hierarchy. - To change a sub-category\'s parent, provide a new `parentId`. - To promote a sub-category to a parent category, set `parentId` to `null`. 
     * @summary Update a category (Admin)
     * @param {string} id The ID of the category to update.
     * @param {UpdateCategoryPayload} updateCategoryPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryIdPut(id: string, updateCategoryPayload: UpdateCategoryPayload, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryIdPut(id, updateCategoryPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all top-level categories (those without a parent).
     * @summary Get all parent categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryParentsGet(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryParentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new category. To create a parent category, omit the `parentId`. To create a sub-category, provide the `parentId` of an existing category.
     * @summary Create a new category (Admin)
     * @param {CreateCategoryPayload} createCategoryPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categoryPost(createCategoryPayload: CreateCategoryPayload, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryPost(createCategoryPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all categories that are children of another category (i.e., their parentId is not null).
     * @summary Get all sub-categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public categorySubCategoriesGet(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categorySubCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }
}

export const CategoryGetTypeEnum = {
    Top: 'top',
    Sub: 'sub'
} as const;
export type CategoryGetTypeEnum = typeof CategoryGetTypeEnum[keyof typeof CategoryGetTypeEnum];


/**
 * ContentApi - axios parameter creator
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the content for a given type, such as PRIVACY_POLICY. This is a public endpoint.
         * @summary Get static content by type
         * @param {ContentType} type The type of content to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypeGet: async (type: ContentType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contentTypeGet', 'type', type)
            const localVarPath = `/content/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypePatch: async (type: ContentType, updateContentPayload: UpdateContentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contentTypePatch', 'type', type)
            // verify required parameter 'updateContentPayload' is not null or undefined
            assertParamExists('contentTypePatch', 'updateContentPayload', updateContentPayload)
            const localVarPath = `/content/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContentPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the content for a given type, such as PRIVACY_POLICY. This is a public endpoint.
         * @summary Get static content by type
         * @param {ContentType} type The type of content to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTypeGet(type: ContentType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Content>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTypeGet(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Content>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contentTypePatch(type, updateContentPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.contentTypePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Retrieves the content for a given type, such as PRIVACY_POLICY. This is a public endpoint.
         * @summary Get static content by type
         * @param {ContentType} type The type of content to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypeGet(type: ContentType, options?: RawAxiosRequestConfig): AxiosPromise<Content> {
            return localVarFp.contentTypeGet(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
         * @summary Update static content by type (Admin)
         * @param {ContentType} type The type of content to update.
         * @param {UpdateContentPayload} updateContentPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig): AxiosPromise<Content> {
            return localVarFp.contentTypePatch(type, updateContentPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 */
export class ContentApi extends BaseAPI {
    /**
     * Retrieves the content for a given type, such as PRIVACY_POLICY. This is a public endpoint.
     * @summary Get static content by type
     * @param {ContentType} type The type of content to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contentTypeGet(type: ContentType, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTypeGet(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates the content for a given type. Requires admin privileges. The content should be an HTML string.
     * @summary Update static content by type (Admin)
     * @param {ContentType} type The type of content to update.
     * @param {UpdateContentPayload} updateContentPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public contentTypePatch(type: ContentType, updateContentPayload: UpdateContentPayload, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).contentTypePatch(type, updateContentPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomersApi - axios parameter creator
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminAllGet: async (name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minAmountSpent !== undefined) {
                localVarQueryParameter['minAmountSpent'] = minAmountSpent;
            }

            if (maxAmountSpent !== undefined) {
                localVarQueryParameter['maxAmountSpent'] = maxAmountSpent;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdGet: async (customerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdGet', 'customerId', customerId)
            const localVarPath = `/customers/admin/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdPatch: async (customerId: string, updateUserPayload: UpdateUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdPatch', 'customerId', customerId)
            // verify required parameter 'updateUserPayload' is not null or undefined
            assertParamExists('customersAdminCustomerIdPatch', 'updateUserPayload', updateUserPayload)
            const localVarPath = `/customers/admin/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet: async (customerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdTransactionsGet', 'customerId', customerId)
            const localVarPath = `/customers/admin/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminOverviewGet: async (days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerIdTransactionsGet: async (customerId: string, vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersCustomerIdTransactionsGet', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of unique customers who have patronized a store. - **Vendor**: Can see customers from all their stores. Can filter by a specific `vendorId`. - **Store Admin/Shopper**: Can only see customers from their assigned store. The `vendorId` filter is ignored. 
         * @summary List customers for a vendor, admin, or shopper
         * @param {string} [vendorId] Optional. For vendors, filters customers by a specific store ID. For staff, this parameter is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdGet(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersAdminCustomerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdPatch(customerId, updateUserPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersAdminCustomerIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdTransactionsGet(customerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersAdminCustomerIdTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomersAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminOverviewGet(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersCustomerIdTransactionsGet(customerId, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersCustomerIdTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of unique customers who have patronized a store. - **Vendor**: Can see customers from all their stores. Can filter by a specific `vendorId`. - **Store Admin/Shopper**: Can only see customers from their assigned store. The `vendorId` filter is ignored. 
         * @summary List customers for a vendor, admin, or shopper
         * @param {string} [vendorId] Optional. For vendors, filters customers by a specific store ID. For staff, this parameter is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.customersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomersApi - factory interface
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all customers (Admin)
         * @param {string} [name] Filter by customer name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minAmountSpent] Filter by minimum total amount spent.
         * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
         * @param {string} [createdAtStart] Filter customers created on or after this date.
         * @param {string} [createdAtEnd] Filter customers created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
         * @summary Get a single customer\'s details (Admin)
         * @param {string} customerId The ID of the customer to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdGet(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a customer\'s profile (Admin)
         * @param {string} customerId The ID of the customer to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdPatch(customerId, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
         * @summary Get platform-wide customer overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): AxiosPromise<CustomersAdminOverviewGet200Response> {
            return localVarFp.customersAdminOverviewGet(days, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.customersCustomerIdTransactionsGet(customerId, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of unique customers who have patronized a store. - **Vendor**: Can see customers from all their stores. Can filter by a specific `vendorId`. - **Store Admin/Shopper**: Can only see customers from their assigned store. The `vendorId` filter is ignored. 
         * @summary List customers for a vendor, admin, or shopper
         * @param {string} [vendorId] Optional. For vendors, filters customers by a specific store ID. For staff, this parameter is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSummary>> {
            return localVarFp.customersGet(vendorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 */
export class CustomersApi extends BaseAPI {
    /**
     * Retrieves a paginated list of all users with the \'customer\' role. Allows filtering by name, status, amount spent, and creation date. Only accessible by admins.
     * @summary Get a paginated list of all customers (Admin)
     * @param {string} [name] Filter by customer name (case-insensitive).
     * @param {boolean} [status] Filter by active status (true/false).
     * @param {number} [minAmountSpent] Filter by minimum total amount spent.
     * @param {number} [maxAmountSpent] Filter by maximum total amount spent.
     * @param {string} [createdAtStart] Filter customers created on or after this date.
     * @param {string} [createdAtEnd] Filter customers created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminAllGet(name?: string, status?: boolean, minAmountSpent?: number, maxAmountSpent?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersAdminAllGet(name, status, minAmountSpent, maxAmountSpent, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information for a specific customer, including their profile and order statistics (total, completed, cancelled). Only accessible by admins.
     * @summary Get a single customer\'s details (Admin)
     * @param {string} customerId The ID of the customer to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdGet(customerId: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersAdminCustomerIdGet(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update a customer\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
     * @summary Update a customer\'s profile (Admin)
     * @param {string} customerId The ID of the customer to update.
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdPatch(customerId: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersAdminCustomerIdPatch(customerId, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
     * @summary Get a paginated list of a customer\'s transactions (Admin)
     * @param {string} customerId The ID of the customer.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about customers, such as total customers, total completed orders (invoices), and new customers in a given period. Only accessible by admins.
     * @summary Get platform-wide customer overview data (Admin)
     * @param {number} [days] The number of past days to count for \&quot;new customers\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersAdminOverviewGet(days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
     * @summary List all transactions for a specific customer
     * @param {string} customerId The ID of the customer.
     * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersCustomerIdTransactionsGet(customerId, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of unique customers who have patronized a store. - **Vendor**: Can see customers from all their stores. Can filter by a specific `vendorId`. - **Store Admin/Shopper**: Can only see customers from their assigned store. The `vendorId` filter is ignored. 
     * @summary List customers for a vendor, admin, or shopper
     * @param {string} [vendorId] Optional. For vendors, filters customers by a specific store ID. For staff, this parameter is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).customersGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeliveryApi - axios parameter creator
 */
export const DeliveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryLocationPost: async (orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryLocationPost', 'orderId', orderId)
            // verify required parameter 'ordersOrderIdDeliveryLocationPostRequest' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryLocationPost', 'ordersOrderIdDeliveryLocationPostRequest', ordersOrderIdDeliveryLocationPostRequest)
            const localVarPath = `/orders/{orderId}/delivery-location`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersOrderIdDeliveryLocationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryPathGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryPathGet', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/delivery-path`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryApi - functional programming interface
 */
export const DeliveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryPersonLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryApi.ordersOrderIdDeliveryLocationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryPersonLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdDeliveryPathGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryApi.ordersOrderIdDeliveryPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeliveryApi - factory interface
 */
export const DeliveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryApiFp(configuration)
    return {
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryPersonLocation> {
            return localVarFp.ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeliveryPersonLocation>> {
            return localVarFp.ordersOrderIdDeliveryPathGet(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeliveryApi - object-oriented interface
 */
export class DeliveryApi extends BaseAPI {
    /**
     * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
     * @summary Add a location point for a delivery person
     * @param {string} orderId The ID of the order being delivered.
     * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig) {
        return DeliveryApiFp(this.configuration).ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
     * @summary Get the delivery path for an order
     * @param {string} orderId The ID of the order to retrieve the path for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig) {
        return DeliveryApiFp(this.configuration).ordersOrderIdDeliveryPathGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeliveryAddressApi - axios parameter creator
 */
export const DeliveryAddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a delivery address by its ID
         * @param {string} id The ID of the delivery address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryAddressIdDelete', 'id', id)
            const localVarPath = `/deliveryAddress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific delivery address by its ID
         * @param {string} id The ID of the delivery address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryAddressIdGet', 'id', id)
            const localVarPath = `/deliveryAddress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a delivery address
         * @param {string} id The ID of the delivery address to update.
         * @param {UpdateDeliveryAddressPayload} updateDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdPut: async (id: string, updateDeliveryAddressPayload: UpdateDeliveryAddressPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryAddressIdPut', 'id', id)
            // verify required parameter 'updateDeliveryAddressPayload' is not null or undefined
            assertParamExists('deliveryAddressIdPut', 'updateDeliveryAddressPayload', updateDeliveryAddressPayload)
            const localVarPath = `/deliveryAddress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeliveryAddressPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a delivery address as the default for the authenticated user
         * @param {string} id The ID of the delivery address to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdSetDefaultPatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryAddressIdSetDefaultPatch', 'id', id)
            const localVarPath = `/deliveryAddress/{id}/set-default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default delivery address for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressMeDefaultGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deliveryAddress/me/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all delivery addresses for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deliveryAddress/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new delivery address for the authenticated user
         * @param {CreateDeliveryAddressPayload} createDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressPost: async (createDeliveryAddressPayload: CreateDeliveryAddressPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDeliveryAddressPayload' is not null or undefined
            assertParamExists('deliveryAddressPost', 'createDeliveryAddressPayload', createDeliveryAddressPayload)
            const localVarPath = `/deliveryAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeliveryAddressPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryAddressApi - functional programming interface
 */
export const DeliveryAddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryAddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a delivery address by its ID
         * @param {string} id The ID of the delivery address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific delivery address by its ID
         * @param {string} id The ID of the delivery address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a delivery address
         * @param {string} id The ID of the delivery address to update.
         * @param {UpdateDeliveryAddressPayload} updateDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressIdPut(id: string, updateDeliveryAddressPayload: UpdateDeliveryAddressPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressIdPut(id, updateDeliveryAddressPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set a delivery address as the default for the authenticated user
         * @param {string} id The ID of the delivery address to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressIdSetDefaultPatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressIdSetDefaultPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressIdSetDefaultPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default delivery address for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressMeDefaultGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressMeDefaultGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressMeDefaultGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all delivery addresses for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryAddress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new delivery address for the authenticated user
         * @param {CreateDeliveryAddressPayload} createDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryAddressPost(createDeliveryAddressPayload: CreateDeliveryAddressPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryAddressPost(createDeliveryAddressPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryAddressApi.deliveryAddressPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeliveryAddressApi - factory interface
 */
export const DeliveryAddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryAddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a delivery address by its ID
         * @param {string} id The ID of the delivery address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific delivery address by its ID
         * @param {string} id The ID of the delivery address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a delivery address
         * @param {string} id The ID of the delivery address to update.
         * @param {UpdateDeliveryAddressPayload} updateDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdPut(id: string, updateDeliveryAddressPayload: UpdateDeliveryAddressPayload, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressIdPut(id, updateDeliveryAddressPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a delivery address as the default for the authenticated user
         * @param {string} id The ID of the delivery address to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressIdSetDefaultPatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressIdSetDefaultPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default delivery address for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressMeDefaultGet(options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressMeDefaultGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all delivery addresses for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<DeliveryAddress>> {
            return localVarFp.deliveryAddressMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new delivery address for the authenticated user
         * @param {CreateDeliveryAddressPayload} createDeliveryAddressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryAddressPost(createDeliveryAddressPayload: CreateDeliveryAddressPayload, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryAddress> {
            return localVarFp.deliveryAddressPost(createDeliveryAddressPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeliveryAddressApi - object-oriented interface
 */
export class DeliveryAddressApi extends BaseAPI {
    /**
     * 
     * @summary Delete a delivery address by its ID
     * @param {string} id The ID of the delivery address to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific delivery address by its ID
     * @param {string} id The ID of the delivery address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a delivery address
     * @param {string} id The ID of the delivery address to update.
     * @param {UpdateDeliveryAddressPayload} updateDeliveryAddressPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressIdPut(id: string, updateDeliveryAddressPayload: UpdateDeliveryAddressPayload, options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressIdPut(id, updateDeliveryAddressPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a delivery address as the default for the authenticated user
     * @param {string} id The ID of the delivery address to set as default.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressIdSetDefaultPatch(id: string, options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressIdSetDefaultPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default delivery address for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressMeDefaultGet(options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressMeDefaultGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all delivery addresses for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressMeGet(options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new delivery address for the authenticated user
     * @param {CreateDeliveryAddressPayload} createDeliveryAddressPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryAddressPost(createDeliveryAddressPayload: CreateDeliveryAddressPayload, options?: RawAxiosRequestConfig) {
        return DeliveryAddressApiFp(this.configuration).deliveryAddressPost(createDeliveryAddressPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeliveryPersonsApi - axios parameter creator
 */
export const DeliveryPersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminAllGet: async (name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/delivery-persons/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minDeliveries !== undefined) {
                localVarQueryParameter['minDeliveries'] = minDeliveries;
            }

            if (maxDeliveries !== undefined) {
                localVarQueryParameter['maxDeliveries'] = maxDeliveries;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdDeliveriesGet: async (id: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdDeliveriesGet', 'id', id)
            const localVarPath = `/delivery-persons/admin/{id}/deliveries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdGet', 'id', id)
            const localVarPath = `/delivery-persons/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdPatch: async (id: string, updateUserPayload: UpdateUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdPatch', 'id', id)
            // verify required parameter 'updateUserPayload' is not null or undefined
            assertParamExists('deliveryPersonsAdminIdPatch', 'updateUserPayload', updateUserPayload)
            const localVarPath = `/delivery-persons/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminOverviewGet: async (days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/delivery-persons/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeliveryPersonsApi - functional programming interface
 */
export const DeliveryPersonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeliveryPersonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryPersonsApi.deliveryPersonsAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdDeliveriesGet(id, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryPersonsApi.deliveryPersonsAdminIdDeliveriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryPersonsApi.deliveryPersonsAdminIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminIdPatch(id, updateUserPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryPersonsApi.deliveryPersonsAdminIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryPersonsAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPersonsAdminOverviewGet(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeliveryPersonsApi.deliveryPersonsAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeliveryPersonsApi - factory interface
 */
export const DeliveryPersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeliveryPersonsApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
         * @summary Get a paginated list of all delivery persons (Admin)
         * @param {string} [name] Filter by name (case-insensitive).
         * @param {boolean} [status] Filter by active status (true/false).
         * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
         * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
         * @param {string} [createdAtStart] Filter users created on or after this date.
         * @param {string} [createdAtEnd] Filter users created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all completed deliveries for a specific delivery person.
         * @summary Get a paginated delivery history for a single delivery person (Admin)
         * @param {string} id The ID of the delivery person.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdDeliveriesGet(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
         * @summary Get a single delivery person\'s details (Admin)
         * @param {string} id The ID of the delivery person to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
         * @summary Update a delivery person\'s profile (Admin)
         * @param {string} id The ID of the delivery person to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deliveryPersonsAdminIdPatch(id, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
         * @summary Get platform-wide delivery person overview data (Admin)
         * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryPersonsAdminOverviewGet200Response> {
            return localVarFp.deliveryPersonsAdminOverviewGet(days, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeliveryPersonsApi - object-oriented interface
 */
export class DeliveryPersonsApi extends BaseAPI {
    /**
     * Retrieves a paginated list of all users with the \'delivery_person\' role. Allows filtering by name, status, number of deliveries, and creation date.
     * @summary Get a paginated list of all delivery persons (Admin)
     * @param {string} [name] Filter by name (case-insensitive).
     * @param {boolean} [status] Filter by active status (true/false).
     * @param {number} [minDeliveries] Filter by minimum number of completed deliveries.
     * @param {number} [maxDeliveries] Filter by maximum number of completed deliveries.
     * @param {string} [createdAtStart] Filter users created on or after this date.
     * @param {string} [createdAtEnd] Filter users created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminAllGet(name?: string, status?: boolean, minDeliveries?: number, maxDeliveries?: number, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DeliveryPersonsApiFp(this.configuration).deliveryPersonsAdminAllGet(name, status, minDeliveries, maxDeliveries, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all completed deliveries for a specific delivery person.
     * @summary Get a paginated delivery history for a single delivery person (Admin)
     * @param {string} id The ID of the delivery person.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdDeliveriesGet(id: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DeliveryPersonsApiFp(this.configuration).deliveryPersonsAdminIdDeliveriesGet(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information for a specific delivery person, including their profile, delivery statistics, and recent delivery history.
     * @summary Get a single delivery person\'s details (Admin)
     * @param {string} id The ID of the delivery person to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DeliveryPersonsApiFp(this.configuration).deliveryPersonsAdminIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update a delivery person\'s profile details. This is primarily used to suspend or reactivate an account by setting the `active` field to `false` or `true`. Other fields like `name`, `email`, etc., can also be updated. 
     * @summary Update a delivery person\'s profile (Admin)
     * @param {string} id The ID of the delivery person to update.
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminIdPatch(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig) {
        return DeliveryPersonsApiFp(this.configuration).deliveryPersonsAdminIdPatch(id, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about delivery persons, such as total count, new sign-ups, and total deliveries. Only accessible by admins.
     * @summary Get platform-wide delivery person overview data (Admin)
     * @param {number} [days] The number of past days to count for \&quot;new delivery persons\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deliveryPersonsAdminOverviewGet(days?: number, options?: RawAxiosRequestConfig) {
        return DeliveryPersonsApiFp(this.configuration).deliveryPersonsAdminOverviewGet(days, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EarningsApi - axios parameter creator
 */
export const EarningsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet: async (period?: EarningsTotalGetPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EarningsApi - functional programming interface
 */
export const EarningsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EarningsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EarningsApi.earningsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarningsTotalGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsTotalGet(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EarningsApi.earningsTotalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EarningsApi - factory interface
 */
export const EarningsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EarningsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.earningsGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): AxiosPromise<EarningsTotalGet200Response> {
            return localVarFp.earningsTotalGet(period, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EarningsApi - object-oriented interface
 */
export class EarningsApi extends BaseAPI {
    /**
     * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
     * @summary List earnings for a vendor
     * @param {string} [vendorId] Optional. Filter earnings for a specific store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return EarningsApiFp(this.configuration).earningsGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
     * @summary Get total earnings for a vendor
     * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig) {
        return EarningsApiFp(this.configuration).earningsTotalGet(period, options).then((request) => request(this.axios, this.basePath));
    }
}

export const EarningsTotalGetPeriodEnum = {
    Today: 'today',
    _7days: '7days',
    _1month: '1month',
    _1year: '1year'
} as const;
export type EarningsTotalGetPeriodEnum = typeof EarningsTotalGetPeriodEnum[keyof typeof EarningsTotalGetPeriodEnum];


/**
 * FeeApi - axios parameter creator
 */
export const FeeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCalculateFeesPost: async (calculateFeesPayload: CalculateFeesPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateFeesPayload' is not null or undefined
            assertParamExists('feesCalculateFeesPost', 'calculateFeesPayload', calculateFeesPayload)
            const localVarPath = `/fees/calculate-fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateFeesPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all current active fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCurrentGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fees/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current active fee for a specific type
         * @param {FeesCurrentTypeGetTypeEnum} type The type of fee to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCurrentTypeGet: async (type: FeesCurrentTypeGetTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('feesCurrentTypeGet', 'type', type)
            const localVarPath = `/fees/current/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivate the current active fee of a specific type
         * @param {FeesDeactivateTypePatchTypeEnum} type The type of fee to deactivate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesDeactivateTypePatch: async (type: FeesDeactivateTypePatchTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('feesDeactivateTypePatch', 'type', type)
            const localVarPath = `/fees/deactivate/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a fee by its ID
         * @param {string} id The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('feesIdDelete', 'id', id)
            const localVarPath = `/fees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing fee
         * @param {string} id The ID of the fee to update.
         * @param {UpdateFeePayload} updateFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesIdPatch: async (id: string, updateFeePayload: UpdateFeePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('feesIdPatch', 'id', id)
            // verify required parameter 'updateFeePayload' is not null or undefined
            assertParamExists('feesIdPatch', 'updateFeePayload', updateFeePayload)
            const localVarPath = `/fees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new fee
         * @param {CreateFeePayload} createFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost: async (createFeePayload: CreateFeePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeePayload' is not null or undefined
            assertParamExists('feesPost', 'createFeePayload', createFeePayload)
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeApi - functional programming interface
 */
export const FeeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateFeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesCalculateFeesPost(calculateFeesPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesCalculateFeesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all current active fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesCurrentGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fee>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesCurrentGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesCurrentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the current active fee for a specific type
         * @param {FeesCurrentTypeGetTypeEnum} type The type of fee to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesCurrentTypeGet(type: FeesCurrentTypeGetTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesCurrentTypeGet(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesCurrentTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deactivate the current active fee of a specific type
         * @param {FeesDeactivateTypePatchTypeEnum} type The type of fee to deactivate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesDeactivateTypePatch(type: FeesDeactivateTypePatchTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesDeactivateTypePatch(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesDeactivateTypePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a fee by its ID
         * @param {string} id The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing fee
         * @param {string} id The ID of the fee to update.
         * @param {UpdateFeePayload} updateFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesIdPatch(id: string, updateFeePayload: UpdateFeePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesIdPatch(id, updateFeePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new fee
         * @param {CreateFeePayload} createFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesPost(createFeePayload: CreateFeePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesPost(createFeePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeApi.feesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeeApi - factory interface
 */
export const FeeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeeApiFp(configuration)
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig): AxiosPromise<CalculateFeesResponse> {
            return localVarFp.feesCalculateFeesPost(calculateFeesPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all current active fees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCurrentGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Fee>> {
            return localVarFp.feesCurrentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current active fee for a specific type
         * @param {FeesCurrentTypeGetTypeEnum} type The type of fee to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCurrentTypeGet(type: FeesCurrentTypeGetTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Fee> {
            return localVarFp.feesCurrentTypeGet(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivate the current active fee of a specific type
         * @param {FeesDeactivateTypePatchTypeEnum} type The type of fee to deactivate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesDeactivateTypePatch(type: FeesDeactivateTypePatchTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Fee> {
            return localVarFp.feesDeactivateTypePatch(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a fee by its ID
         * @param {string} id The ID of the fee to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Fee> {
            return localVarFp.feesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing fee
         * @param {string} id The ID of the fee to update.
         * @param {UpdateFeePayload} updateFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesIdPatch(id: string, updateFeePayload: UpdateFeePayload, options?: RawAxiosRequestConfig): AxiosPromise<Fee> {
            return localVarFp.feesIdPatch(id, updateFeePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new fee
         * @param {CreateFeePayload} createFeePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesPost(createFeePayload: CreateFeePayload, options?: RawAxiosRequestConfig): AxiosPromise<Fee> {
            return localVarFp.feesPost(createFeePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeApi - object-oriented interface
 */
export class FeeApi extends BaseAPI {
    /**
     * 
     * @summary Calculate the total estimated cost for an order
     * @param {CalculateFeesPayload} calculateFeesPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesCalculateFeesPost(calculateFeesPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all current active fees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesCurrentGet(options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesCurrentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current active fee for a specific type
     * @param {FeesCurrentTypeGetTypeEnum} type The type of fee to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesCurrentTypeGet(type: FeesCurrentTypeGetTypeEnum, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesCurrentTypeGet(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivate the current active fee of a specific type
     * @param {FeesDeactivateTypePatchTypeEnum} type The type of fee to deactivate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesDeactivateTypePatch(type: FeesDeactivateTypePatchTypeEnum, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesDeactivateTypePatch(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a fee by its ID
     * @param {string} id The ID of the fee to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing fee
     * @param {string} id The ID of the fee to update.
     * @param {UpdateFeePayload} updateFeePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesIdPatch(id: string, updateFeePayload: UpdateFeePayload, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesIdPatch(id, updateFeePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new fee
     * @param {CreateFeePayload} createFeePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesPost(createFeePayload: CreateFeePayload, options?: RawAxiosRequestConfig) {
        return FeeApiFp(this.configuration).feesPost(createFeePayload, options).then((request) => request(this.axios, this.basePath));
    }
}

export const FeesCurrentTypeGetTypeEnum = {
    Delivery: 'delivery',
    Service: 'service',
    Shopping: 'shopping'
} as const;
export type FeesCurrentTypeGetTypeEnum = typeof FeesCurrentTypeGetTypeEnum[keyof typeof FeesCurrentTypeGetTypeEnum];
export const FeesDeactivateTypePatchTypeEnum = {
    Delivery: 'delivery',
    Service: 'service',
    Shopping: 'shopping'
} as const;
export type FeesDeactivateTypePatchTypeEnum = typeof FeesDeactivateTypePatchTypeEnum[keyof typeof FeesDeactivateTypePatchTypeEnum];


/**
 * GeneralApi - axios parameter creator
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a flat list of UTC timezone strings.
         * @summary Get a list of all supported timezones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTimeZonesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/time-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 */
export const GeneralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a flat list of UTC timezone strings.
         * @summary Get a list of all supported timezones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTimeZonesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTimeZonesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTimeZonesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralApi.authTimeZonesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeneralApi - factory interface
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralApiFp(configuration)
    return {
        /**
         * Returns a flat list of UTC timezone strings.
         * @summary Get a list of all supported timezones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTimeZonesGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthTimeZonesGet200Response> {
            return localVarFp.authTimeZonesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralApi - object-oriented interface
 */
export class GeneralApi extends BaseAPI {
    /**
     * Returns a flat list of UTC timezone strings.
     * @summary Get a list of all supported timezones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authTimeZonesGet(options?: RawAxiosRequestConfig) {
        return GeneralApiFp(this.configuration).authTimeZonesGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeneralSearchApi - axios parameter creator
 */
export const GeneralSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Searches for a category by ID and returns a list of stores that sell products in that category (and its sub-categories), sorted by proximity to the user.
         * @summary Find stores by category ID
         * @param {string} categoryId The ID of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchCategoryCategoryIdGet: async (categoryId: string, latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('generalSearchCategoryCategoryIdGet', 'categoryId', categoryId)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('generalSearchCategoryCategoryIdGet', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('generalSearchCategoryCategoryIdGet', 'longitude', longitude)
            const localVarPath = `/generalSearch/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for a category by name and returns a list of stores that sell products in that category, sorted by proximity to the user.
         * @summary Find stores by category name
         * @param {string} search The name of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchCategoryGet: async (search: string, latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('generalSearchCategoryGet', 'search', search)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('generalSearchCategoryGet', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('generalSearchCategoryGet', 'longitude', longitude)
            const localVarPath = `/generalSearch/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for a product by name and returns a list of stores that sell it, sorted by proximity to the user. Each store result includes other products they sell.
         * @summary Find stores that sell a specific product
         * @param {string} search The name of the product to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchProductGet: async (search: string, latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('generalSearchProductGet', 'search', search)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('generalSearchProductGet', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('generalSearchProductGet', 'longitude', longitude)
            const localVarPath = `/generalSearch/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for a store by name and returns a list of stores, sorted by proximity to the user. Each store result includes products they sell.
         * @summary Find stores by name
         * @param {string} search The name of the store to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchStoreGet: async (search: string, latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('generalSearchStoreGet', 'search', search)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('generalSearchStoreGet', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('generalSearchStoreGet', 'longitude', longitude)
            const localVarPath = `/generalSearch/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for products within a specific store, optionally filtering by a search term and/or category. If no categoryId is provided, it returns products grouped by their parent category. If a categoryId is provided, it returns a flat list of products within that category. 
         * @summary Search for products within a specific store
         * @param {string} storeId The ID of the store (vendor) to search within.
         * @param {string} [searchTerm] The search term to filter products by name.
         * @param {string} [categoryId] The ID of the category to filter products by. If provided, results will not be grouped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchStoreProductsStoreIdGet: async (storeId: string, searchTerm?: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('generalSearchStoreProductsStoreIdGet', 'storeId', storeId)
            const localVarPath = `/generalSearch/storeProducts/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralSearchApi - functional programming interface
 */
export const GeneralSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Searches for a category by ID and returns a list of stores that sell products in that category (and its sub-categories), sorted by proximity to the user.
         * @summary Find stores by category ID
         * @param {string} categoryId The ID of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalSearchCategoryCategoryIdGet(categoryId: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresByProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalSearchCategoryCategoryIdGet(categoryId, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSearchApi.generalSearchCategoryCategoryIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for a category by name and returns a list of stores that sell products in that category, sorted by proximity to the user.
         * @summary Find stores by category name
         * @param {string} search The name of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalSearchCategoryGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresByProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalSearchCategoryGet(search, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSearchApi.generalSearchCategoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for a product by name and returns a list of stores that sell it, sorted by proximity to the user. Each store result includes other products they sell.
         * @summary Find stores that sell a specific product
         * @param {string} search The name of the product to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalSearchProductGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresByProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalSearchProductGet(search, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSearchApi.generalSearchProductGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for a store by name and returns a list of stores, sorted by proximity to the user. Each store result includes products they sell.
         * @summary Find stores by name
         * @param {string} search The name of the store to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalSearchStoreGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoresByProductResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalSearchStoreGet(search, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSearchApi.generalSearchStoreGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for products within a specific store, optionally filtering by a search term and/or category. If no categoryId is provided, it returns products grouped by their parent category. If a categoryId is provided, it returns a flat list of products within that category. 
         * @summary Search for products within a specific store
         * @param {string} storeId The ID of the store (vendor) to search within.
         * @param {string} [searchTerm] The search term to filter products by name.
         * @param {string} [categoryId] The ID of the category to filter products by. If provided, results will not be grouped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalSearchStoreProductsStoreIdGet(storeId: string, searchTerm?: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralSearchStoreProductsStoreIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalSearchStoreProductsStoreIdGet(storeId, searchTerm, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeneralSearchApi.generalSearchStoreProductsStoreIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeneralSearchApi - factory interface
 */
export const GeneralSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralSearchApiFp(configuration)
    return {
        /**
         * Searches for a category by ID and returns a list of stores that sell products in that category (and its sub-categories), sorted by proximity to the user.
         * @summary Find stores by category ID
         * @param {string} categoryId The ID of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchCategoryCategoryIdGet(categoryId: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): AxiosPromise<StoresByProductResult> {
            return localVarFp.generalSearchCategoryCategoryIdGet(categoryId, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for a category by name and returns a list of stores that sell products in that category, sorted by proximity to the user.
         * @summary Find stores by category name
         * @param {string} search The name of the category to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchCategoryGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): AxiosPromise<StoresByProductResult> {
            return localVarFp.generalSearchCategoryGet(search, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for a product by name and returns a list of stores that sell it, sorted by proximity to the user. Each store result includes other products they sell.
         * @summary Find stores that sell a specific product
         * @param {string} search The name of the product to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchProductGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): AxiosPromise<StoresByProductResult> {
            return localVarFp.generalSearchProductGet(search, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for a store by name and returns a list of stores, sorted by proximity to the user. Each store result includes products they sell.
         * @summary Find stores by name
         * @param {string} search The name of the store to search for.
         * @param {number} latitude User\&#39;s current latitude.
         * @param {number} longitude User\&#39;s current longitude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchStoreGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig): AxiosPromise<StoresByProductResult> {
            return localVarFp.generalSearchStoreGet(search, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for products within a specific store, optionally filtering by a search term and/or category. If no categoryId is provided, it returns products grouped by their parent category. If a categoryId is provided, it returns a flat list of products within that category. 
         * @summary Search for products within a specific store
         * @param {string} storeId The ID of the store (vendor) to search within.
         * @param {string} [searchTerm] The search term to filter products by name.
         * @param {string} [categoryId] The ID of the category to filter products by. If provided, results will not be grouped.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalSearchStoreProductsStoreIdGet(storeId: string, searchTerm?: string, categoryId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GeneralSearchStoreProductsStoreIdGet200Response> {
            return localVarFp.generalSearchStoreProductsStoreIdGet(storeId, searchTerm, categoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralSearchApi - object-oriented interface
 */
export class GeneralSearchApi extends BaseAPI {
    /**
     * Searches for a category by ID and returns a list of stores that sell products in that category (and its sub-categories), sorted by proximity to the user.
     * @summary Find stores by category ID
     * @param {string} categoryId The ID of the category to search for.
     * @param {number} latitude User\&#39;s current latitude.
     * @param {number} longitude User\&#39;s current longitude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalSearchCategoryCategoryIdGet(categoryId: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig) {
        return GeneralSearchApiFp(this.configuration).generalSearchCategoryCategoryIdGet(categoryId, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for a category by name and returns a list of stores that sell products in that category, sorted by proximity to the user.
     * @summary Find stores by category name
     * @param {string} search The name of the category to search for.
     * @param {number} latitude User\&#39;s current latitude.
     * @param {number} longitude User\&#39;s current longitude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalSearchCategoryGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig) {
        return GeneralSearchApiFp(this.configuration).generalSearchCategoryGet(search, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for a product by name and returns a list of stores that sell it, sorted by proximity to the user. Each store result includes other products they sell.
     * @summary Find stores that sell a specific product
     * @param {string} search The name of the product to search for.
     * @param {number} latitude User\&#39;s current latitude.
     * @param {number} longitude User\&#39;s current longitude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalSearchProductGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig) {
        return GeneralSearchApiFp(this.configuration).generalSearchProductGet(search, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for a store by name and returns a list of stores, sorted by proximity to the user. Each store result includes products they sell.
     * @summary Find stores by name
     * @param {string} search The name of the store to search for.
     * @param {number} latitude User\&#39;s current latitude.
     * @param {number} longitude User\&#39;s current longitude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalSearchStoreGet(search: string, latitude: number, longitude: number, options?: RawAxiosRequestConfig) {
        return GeneralSearchApiFp(this.configuration).generalSearchStoreGet(search, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for products within a specific store, optionally filtering by a search term and/or category. If no categoryId is provided, it returns products grouped by their parent category. If a categoryId is provided, it returns a flat list of products within that category. 
     * @summary Search for products within a specific store
     * @param {string} storeId The ID of the store (vendor) to search within.
     * @param {string} [searchTerm] The search term to filter products by name.
     * @param {string} [categoryId] The ID of the category to filter products by. If provided, results will not be grouped.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalSearchStoreProductsStoreIdGet(storeId: string, searchTerm?: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return GeneralSearchApiFp(this.configuration).generalSearchStoreProductsStoreIdGet(storeId, searchTerm, categoryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A simple endpoint to check if the API is running. Can be used by monitoring services to keep the server from sleeping on free tiers.
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * A simple endpoint to check if the API is running. Can be used by monitoring services to keep the server from sleeping on free tiers.
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * A simple endpoint to check if the API is running. Can be used by monitoring services to keep the server from sleeping on free tiers.
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthGet200Response> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * A simple endpoint to check if the API is running. Can be used by monitoring services to keep the server from sleeping on free tiers.
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads a file (image, document, etc.) to the server. The file is stored on Cloudinary, and a corresponding record is created in the database. This endpoint requires a `multipart/form-data` request. 
         * @summary Upload a media file
         * @param {File} file The file to upload.
         * @param {string} referenceId The ID of the resource this media is associated with (e.g., a user ID, product ID).
         * @param {MediaUploadPostReferenceTypeEnum} referenceType The type of resource the media is associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadPost: async (file: File, referenceId: string, referenceType: MediaUploadPostReferenceTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('mediaUploadPost', 'file', file)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('mediaUploadPost', 'referenceId', referenceId)
            // verify required parameter 'referenceType' is not null or undefined
            assertParamExists('mediaUploadPost', 'referenceType', referenceType)
            const localVarPath = `/media/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (referenceId !== undefined) { 
                localVarFormParams.append('referenceId', referenceId as any);
            }
    
            if (referenceType !== undefined) { 
                localVarFormParams.append('referenceType', referenceType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Uploads a file (image, document, etc.) to the server. The file is stored on Cloudinary, and a corresponding record is created in the database. This endpoint requires a `multipart/form-data` request. 
         * @summary Upload a media file
         * @param {File} file The file to upload.
         * @param {string} referenceId The ID of the resource this media is associated with (e.g., a user ID, product ID).
         * @param {MediaUploadPostReferenceTypeEnum} referenceType The type of resource the media is associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaUploadPost(file: File, referenceId: string, referenceType: MediaUploadPostReferenceTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUploadPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaUploadPost(file, referenceId, referenceType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * Uploads a file (image, document, etc.) to the server. The file is stored on Cloudinary, and a corresponding record is created in the database. This endpoint requires a `multipart/form-data` request. 
         * @summary Upload a media file
         * @param {File} file The file to upload.
         * @param {string} referenceId The ID of the resource this media is associated with (e.g., a user ID, product ID).
         * @param {MediaUploadPostReferenceTypeEnum} referenceType The type of resource the media is associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaUploadPost(file: File, referenceId: string, referenceType: MediaUploadPostReferenceTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<MediaUploadPost201Response> {
            return localVarFp.mediaUploadPost(file, referenceId, referenceType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 */
export class MediaApi extends BaseAPI {
    /**
     * Uploads a file (image, document, etc.) to the server. The file is stored on Cloudinary, and a corresponding record is created in the database. This endpoint requires a `multipart/form-data` request. 
     * @summary Upload a media file
     * @param {File} file The file to upload.
     * @param {string} referenceId The ID of the resource this media is associated with (e.g., a user ID, product ID).
     * @param {MediaUploadPostReferenceTypeEnum} referenceType The type of resource the media is associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mediaUploadPost(file: File, referenceId: string, referenceType: MediaUploadPostReferenceTypeEnum, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaUploadPost(file, referenceId, referenceType, options).then((request) => request(this.axios, this.basePath));
    }
}

export const MediaUploadPostReferenceTypeEnum = {
    BugReportImage: 'bug_report_image',
    UserImage: 'user_image',
    StoreImage: 'store_image',
    ProductImage: 'product_image',
    CategoryImage: 'category_image',
    Document: 'document',
    Other: 'other'
} as const;
export type MediaUploadPostReferenceTypeEnum = typeof MediaUploadPostReferenceTypeEnum[keyof typeof MediaUploadPostReferenceTypeEnum];


/**
 * MessagingApi - axios parameter creator
 */
export const MessagingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAdminOrderIdMessagesGet', 'orderId', orderId)
            const localVarPath = `/order/admin/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesGet', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesPost: async (orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesPost', 'orderId', orderId)
            // verify required parameter 'orderOrderIdMessagesPostRequest' is not null or undefined
            assertParamExists('orderOrderIdMessagesPost', 'orderOrderIdMessagesPostRequest', orderOrderIdMessagesPostRequest)
            const localVarPath = `/order/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderOrderIdMessagesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesReadPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesReadPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/messages/read`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagingApi - functional programming interface
 */
export const MessagingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOrderIdMessagesGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagingApi.orderAdminOrderIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagingApi.orderOrderIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagingApi.orderOrderIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderOrderIdMessagesReadPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesReadPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagingApi.orderOrderIdMessagesReadPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagingApi - factory interface
 */
export const MessagingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagingApiFp(configuration)
    return {
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageWithRelations>> {
            return localVarFp.orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageWithRelations>> {
            return localVarFp.orderOrderIdMessagesGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageWithRelations> {
            return localVarFp.orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderOrderIdMessagesReadPatch200Response> {
            return localVarFp.orderOrderIdMessagesReadPatch(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagingApi - object-oriented interface
 */
export class MessagingApi extends BaseAPI {
    /**
     * Retrieves the complete conversation history for a specific order. Only accessible by admins.
     * @summary Get all messages for an order (Admin)
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig) {
        return MessagingApiFp(this.configuration).orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
     * @summary Get messages for an order
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig) {
        return MessagingApiFp(this.configuration).orderOrderIdMessagesGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
     * @summary Send a message related to an order
     * @param {string} orderId The ID of the order.
     * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return MessagingApiFp(this.configuration).orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
     * @summary Mark messages as read
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return MessagingApiFp(this.configuration).orderOrderIdMessagesReadPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFcmTokenDelete: async (fcmToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fcmToken' is not null or undefined
            assertParamExists('devicesFcmTokenDelete', 'fcmToken', fcmToken)
            const localVarPath = `/devices/{fcmToken}`
                .replace(`{${"fcmToken"}}`, encodeURIComponent(String(fcmToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost: async (devicesPostRequest: DevicesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'devicesPostRequest' is not null or undefined
            assertParamExists('devicesPost', 'devicesPostRequest', devicesPostRequest)
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(devicesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notifications for the authenticated user
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a specific notification as read
         * @param {string} notificationId The ID of the notification to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsNotificationIdReadPatch: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('notificationsNotificationIdReadPatch', 'notificationId', notificationId)
            const localVarPath = `/notifications/{notificationId}/read`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark all unread notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadAllPatch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/read-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the count of unread notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUnreadCountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/unread-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesFcmTokenDelete(fcmToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.devicesFcmTokenDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPost(devicesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.devicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get notifications for the authenticated user
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.notificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark a specific notification as read
         * @param {string} notificationId The ID of the notification to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsNotificationIdReadPatch(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsNotificationIdReadPatch(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.notificationsNotificationIdReadPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark all unread notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsReadAllPatch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsReadAllPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsReadAllPatch(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.notificationsReadAllPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the count of unread notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsUnreadCountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsReadAllPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsUnreadCountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.notificationsUnreadCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesFcmTokenDelete(fcmToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.devicesPost(devicesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get notifications for the authenticated user
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNotifications> {
            return localVarFp.notificationsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a specific notification as read
         * @param {string} notificationId The ID of the notification to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsNotificationIdReadPatch(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.notificationsNotificationIdReadPatch(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark all unread notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsReadAllPatch(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsReadAllPatch200Response> {
            return localVarFp.notificationsReadAllPatch(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the count of unread notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUnreadCountGet(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsReadAllPatch200Response> {
            return localVarFp.notificationsUnreadCountGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @summary Unregister a device for push notifications
     * @param {string} fcmToken The FCM token of the device to unregister.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).devicesFcmTokenDelete(fcmToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a device for push notifications
     * @param {DevicesPostRequest} devicesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).devicesPost(devicesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get notifications for the authenticated user
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a specific notification as read
     * @param {string} notificationId The ID of the notification to mark as read.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsNotificationIdReadPatch(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationsNotificationIdReadPatch(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark all unread notifications as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsReadAllPatch(options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationsReadAllPatch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the count of unread notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationsUnreadCountGet(options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationsUnreadCountGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCalculateFeesPost: async (calculateFeesPayload: CalculateFeesPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateFeesPayload' is not null or undefined
            assertParamExists('feesCalculateFeesPost', 'calculateFeesPayload', calculateFeesPayload)
            const localVarPath = `/fees/calculate-fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateFeesPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminAllGet: async (orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderCode !== undefined) {
                localVarQueryParameter['orderCode'] = orderCode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAdminOrderIdMessagesGet', 'orderId', orderId)
            const localVarPath = `/order/admin/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdPatch: async (orderId: string, updateOrderPayload: UpdateOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderAdminOrderIdPatch', 'orderId', orderId)
            // verify required parameter 'updateOrderPayload' is not null or undefined
            assertParamExists('orderAdminOrderIdPatch', 'updateOrderPayload', updateOrderPayload)
            const localVarPath = `/order/admin/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available delivery time slots
         * @param {string} vendorId The ID of the vendor.
         * @param {DeliveryMethod} deliveryMethod The delivery method for the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDeliverySlotsGet: async (vendorId: string, deliveryMethod: DeliveryMethod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('orderDeliverySlotsGet', 'vendorId', vendorId)
            // verify required parameter 'deliveryMethod' is not null or undefined
            assertParamExists('orderDeliverySlotsGet', 'deliveryMethod', deliveryMethod)
            const localVarPath = `/order/delivery-slots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (deliveryMethod !== undefined) {
                localVarQueryParameter['deliveryMethod'] = deliveryMethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an order by its ID
         * @param {string} id The ID of the order to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderIdGet', 'id', id)
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdPatch: async (id: string, updateOrderPayload: UpdateOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderIdPatch', 'id', id)
            // verify required parameter 'updateOrderPayload' is not null or undefined
            assertParamExists('orderIdPatch', 'updateOrderPayload', updateOrderPayload)
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderStatusPayload} updateOrderStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdStatusPatch: async (id: string, updateOrderStatusPayload: UpdateOrderStatusPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderIdStatusPatch', 'id', id)
            // verify required parameter 'updateOrderStatusPayload' is not null or undefined
            assertParamExists('orderIdStatusPatch', 'updateOrderStatusPayload', updateOrderStatusPayload)
            const localVarPath = `/order/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a vendor or their staff to verify an order for pickup by providing a 6-digit OTP. Upon successful verification, the order status is automatically transitioned. - If `deliveryMethod` is `customer_pickup`, status changes from `ready_for_pickup` to `picked_up_by_customer`. - If `deliveryMethod` is `delivery_person`, status changes from `ready_for_delivery` to `en_route`. 
         * @summary Verify order pickup with an OTP
         * @param {string} id The ID of the order to verify.
         * @param {OrderIdVerifyPickupPostRequest} orderIdVerifyPickupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdVerifyPickupPost: async (id: string, orderIdVerifyPickupPostRequest: OrderIdVerifyPickupPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderIdVerifyPickupPost', 'id', id)
            // verify required parameter 'orderIdVerifyPickupPostRequest' is not null or undefined
            assertParamExists('orderIdVerifyPickupPost', 'orderIdVerifyPickupPostRequest', orderIdVerifyPickupPostRequest)
            const localVarPath = `/order/{id}/verify-pickup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderIdVerifyPickupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdAcceptPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/accept`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch: async (orderId: string, declineOrderPayload?: DeclineOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdDeclinePatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/decline`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a customer to approve or reject a replacement suggested by the shopper.
         * @summary Respond to a suggested item replacement
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {RespondToReplacementPayload} respondToReplacementPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdRespondToReplacementPatch: async (orderId: string, itemId: string, respondToReplacementPayload: RespondToReplacementPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdRespondToReplacementPatch', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdRespondToReplacementPatch', 'itemId', itemId)
            // verify required parameter 'respondToReplacementPayload' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdRespondToReplacementPatch', 'respondToReplacementPayload', respondToReplacementPayload)
            const localVarPath = `/order/{orderId}/items/{itemId}/respond-to-replacement`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(respondToReplacementPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch: async (orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'itemId', itemId)
            // verify required parameter 'updateOrderItemShoppingStatusPayload' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'updateOrderItemShoppingStatusPayload', updateOrderItemShoppingStatusPayload)
            const localVarPath = `/order/{orderId}/items/{itemId}/update-shopping-status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderItemShoppingStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesGet', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesPost: async (orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesPost', 'orderId', orderId)
            // verify required parameter 'orderOrderIdMessagesPostRequest' is not null or undefined
            assertParamExists('orderOrderIdMessagesPost', 'orderOrderIdMessagesPostRequest', orderOrderIdMessagesPostRequest)
            const localVarPath = `/order/{orderId}/messages`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderOrderIdMessagesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesReadPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdMessagesReadPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/messages/read`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdStartShoppingPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/start-shopping`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a customer to add or update tips for the shopper and/or delivery person after an order has been placed. This will recalculate the order\'s total amount.
         * @summary Add or update a tip for an order
         * @param {string} orderId The ID of the order to add a tip to.
         * @param {UpdateTipPayload} updateTipPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdTipPatch: async (orderId: string, updateTipPayload: UpdateTipPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdTipPatch', 'orderId', orderId)
            // verify required parameter 'updateTipPayload' is not null or undefined
            assertParamExists('orderOrderIdTipPatch', 'updateTipPayload', updateTipPayload)
            const localVarPath = `/order/{orderId}/tip`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTipPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new order based on a payload sent from the client, which includes all order items and delivery details. This endpoint is used when the cart state is managed on the client-side.
         * @summary Create an order from a client payload
         * @param {CreateOrderClientPayload} createOrderClientPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost: async (createOrderClientPayload: CreateOrderClientPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderClientPayload' is not null or undefined
            assertParamExists('orderPost', 'createOrderClientPayload', createOrderClientPayload)
            const localVarPath = `/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderClientPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all orders for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUserMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet: async (vendorId?: string, status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet: async (status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendorOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryLocationPost: async (orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryLocationPost', 'orderId', orderId)
            // verify required parameter 'ordersOrderIdDeliveryLocationPostRequest' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryLocationPost', 'ordersOrderIdDeliveryLocationPostRequest', ordersOrderIdDeliveryLocationPostRequest)
            const localVarPath = `/orders/{orderId}/delivery-location`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersOrderIdDeliveryLocationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryPathGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdDeliveryPathGet', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/delivery-path`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateFeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feesCalculateFeesPost(calculateFeesPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.feesCalculateFeesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOrderIdMessagesGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderAdminOrderIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOrderIdPatch(orderId, updateOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderAdminOrderIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get available delivery time slots
         * @param {string} vendorId The ID of the vendor.
         * @param {DeliveryMethod} deliveryMethod The delivery method for the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDeliverySlotsGet(vendorId: string, deliveryMethod: DeliveryMethod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliverySlot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDeliverySlotsGet(vendorId, deliveryMethod, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderDeliverySlotsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an order by its ID
         * @param {string} id The ID of the order to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIdPatch(id: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIdPatch(id, updateOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the status of an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderStatusPayload} updateOrderStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIdStatusPatch(id: string, updateOrderStatusPayload: UpdateOrderStatusPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIdStatusPatch(id, updateOrderStatusPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a vendor or their staff to verify an order for pickup by providing a 6-digit OTP. Upon successful verification, the order status is automatically transitioned. - If `deliveryMethod` is `customer_pickup`, status changes from `ready_for_pickup` to `picked_up_by_customer`. - If `deliveryMethod` is `delivery_person`, status changes from `ready_for_delivery` to `en_route`. 
         * @summary Verify order pickup with an OTP
         * @param {string} id The ID of the order to verify.
         * @param {OrderIdVerifyPickupPostRequest} orderIdVerifyPickupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIdVerifyPickupPost(id: string, orderIdVerifyPickupPostRequest: OrderIdVerifyPickupPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIdVerifyPickupPost(id, orderIdVerifyPickupPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderIdVerifyPickupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdAcceptPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdDeclinePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a customer to approve or reject a replacement suggested by the shopper.
         * @summary Respond to a suggested item replacement
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {RespondToReplacementPayload} respondToReplacementPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdItemsItemIdRespondToReplacementPatch(orderId: string, itemId: string, respondToReplacementPayload: RespondToReplacementPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdItemsItemIdRespondToReplacementPatch(orderId, itemId, respondToReplacementPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdItemsItemIdRespondToReplacementPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdItemsItemIdUpdateShoppingStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderOrderIdMessagesReadPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdMessagesReadPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdMessagesReadPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdStartShoppingPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdStartShoppingPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a customer to add or update tips for the shopper and/or delivery person after an order has been placed. This will recalculate the order\'s total amount.
         * @summary Add or update a tip for an order
         * @param {string} orderId The ID of the order to add a tip to.
         * @param {UpdateTipPayload} updateTipPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdTipPatch(orderId: string, updateTipPayload: UpdateTipPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdTipPatch(orderId, updateTipPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderOrderIdTipPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new order based on a payload sent from the client, which includes all order items and delivery details. This endpoint is used when the cart state is managed on the client-side.
         * @summary Create an order from a client payload
         * @param {CreateOrderClientPayload} createOrderClientPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPost(createOrderClientPayload: CreateOrderClientPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPost(createOrderClientPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all orders for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderUserMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderUserMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderUserMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorGet(vendorId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorOrdersGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderVendorOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryPersonLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.ordersOrderIdDeliveryLocationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryPersonLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdDeliveryPathGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.ordersOrderIdDeliveryPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @summary Calculate the total estimated cost for an order
         * @param {CalculateFeesPayload} calculateFeesPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig): AxiosPromise<CalculateFeesResponse> {
            return localVarFp.feesCalculateFeesPost(calculateFeesPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
         * @summary Get a paginated list of all orders (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {OrderStatus} [status] Filter by order status.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {string} [createdAtStart] Filter orders created on or after this date.
         * @param {string} [createdAtEnd] Filter orders created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete conversation history for a specific order. Only accessible by admins.
         * @summary Get all messages for an order (Admin)
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageWithRelations>> {
            return localVarFp.orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
         * @summary Update an order\'s details (Admin)
         * @param {string} orderId The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderAdminOrderIdPatch(orderId, updateOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
         * @summary Get platform-wide order overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<OrderAdminOverviewGet200Response> {
            return localVarFp.orderAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available delivery time slots
         * @param {string} vendorId The ID of the vendor.
         * @param {DeliveryMethod} deliveryMethod The delivery method for the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDeliverySlotsGet(vendorId: string, deliveryMethod: DeliveryMethod, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeliverySlot>> {
            return localVarFp.orderDeliverySlotsGet(vendorId, deliveryMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an order by its ID
         * @param {string} id The ID of the order to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorOrder> {
            return localVarFp.orderIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderPayload} updateOrderPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdPatch(id: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderIdPatch(id, updateOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of an order
         * @param {string} id The ID of the order to update.
         * @param {UpdateOrderStatusPayload} updateOrderStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdStatusPatch(id: string, updateOrderStatusPayload: UpdateOrderStatusPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderIdStatusPatch(id, updateOrderStatusPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a vendor or their staff to verify an order for pickup by providing a 6-digit OTP. Upon successful verification, the order status is automatically transitioned. - If `deliveryMethod` is `customer_pickup`, status changes from `ready_for_pickup` to `picked_up_by_customer`. - If `deliveryMethod` is `delivery_person`, status changes from `ready_for_delivery` to `en_route`. 
         * @summary Verify order pickup with an OTP
         * @param {string} id The ID of the order to verify.
         * @param {OrderIdVerifyPickupPostRequest} orderIdVerifyPickupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIdVerifyPickupPost(id: string, orderIdVerifyPickupPostRequest: OrderIdVerifyPickupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderIdVerifyPickupPost(id, orderIdVerifyPickupPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdAcceptPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a customer to approve or reject a replacement suggested by the shopper.
         * @summary Respond to a suggested item replacement
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {RespondToReplacementPayload} respondToReplacementPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdRespondToReplacementPatch(orderId: string, itemId: string, respondToReplacementPayload: RespondToReplacementPayload, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
            return localVarFp.orderOrderIdItemsItemIdRespondToReplacementPatch(orderId, itemId, respondToReplacementPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
            return localVarFp.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
         * @summary Get messages for an order
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageWithRelations>> {
            return localVarFp.orderOrderIdMessagesGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
         * @summary Send a message related to an order
         * @param {string} orderId The ID of the order.
         * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageWithRelations> {
            return localVarFp.orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
         * @summary Mark messages as read
         * @param {string} orderId The ID of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderOrderIdMessagesReadPatch200Response> {
            return localVarFp.orderOrderIdMessagesReadPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a customer to add or update tips for the shopper and/or delivery person after an order has been placed. This will recalculate the order\'s total amount.
         * @summary Add or update a tip for an order
         * @param {string} orderId The ID of the order to add a tip to.
         * @param {UpdateTipPayload} updateTipPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdTipPatch(orderId: string, updateTipPayload: UpdateTipPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdTipPatch(orderId, updateTipPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new order based on a payload sent from the client, which includes all order items and delivery details. This endpoint is used when the cart state is managed on the client-side.
         * @summary Create an order from a client payload
         * @param {CreateOrderClientPayload} createOrderClientPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(createOrderClientPayload: CreateOrderClientPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorOrder> {
            return localVarFp.orderPost(createOrderClientPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all orders for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUserMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
            return localVarFp.orderUserMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.orderVendorGet(vendorId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
            return localVarFp.orderVendorOrdersGet(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
         * @summary Add a location point for a delivery person
         * @param {string} orderId The ID of the order being delivered.
         * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryPersonLocation> {
            return localVarFp.ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
         * @summary Get the delivery path for an order
         * @param {string} orderId The ID of the order to retrieve the path for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeliveryPersonLocation>> {
            return localVarFp.ordersOrderIdDeliveryPathGet(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary Calculate the total estimated cost for an order
     * @param {CalculateFeesPayload} calculateFeesPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feesCalculateFeesPost(calculateFeesPayload: CalculateFeesPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).feesCalculateFeesPost(calculateFeesPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all orders on the platform. Allows filtering by orderCode, status, creation date, and customer name. Only accessible by admins.
     * @summary Get a paginated list of all orders (Admin)
     * @param {string} [orderCode] Filter by order code.
     * @param {OrderStatus} [status] Filter by order status.
     * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
     * @param {string} [createdAtStart] Filter orders created on or after this date.
     * @param {string} [createdAtEnd] Filter orders created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminAllGet(orderCode?: string, status?: OrderStatus, customerName?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderAdminAllGet(orderCode, status, customerName, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the complete conversation history for a specific order. Only accessible by admins.
     * @summary Get all messages for an order (Admin)
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderAdminOrderIdMessagesGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to update specific fields of an order to resolve issues or \"un-stuck\" it. Fields that can be updated include `orderStatus`, `paymentStatus`, `shopperId`, `deliveryPersonId`, etc. **Warning**: Changing `orderStatus` to `delivered` will trigger payout logic. 
     * @summary Update an order\'s details (Admin)
     * @param {string} orderId The ID of the order to update.
     * @param {UpdateOrderPayload} updateOrderPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOrderIdPatch(orderId: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderAdminOrderIdPatch(orderId, updateOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about all orders on the platform, such as total orders, total products ordered, and total cancelled orders. Only accessible by admins.
     * @summary Get platform-wide order overview data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available delivery time slots
     * @param {string} vendorId The ID of the vendor.
     * @param {DeliveryMethod} deliveryMethod The delivery method for the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderDeliverySlotsGet(vendorId: string, deliveryMethod: DeliveryMethod, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderDeliverySlotsGet(vendorId, deliveryMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an order by its ID
     * @param {string} id The ID of the order to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an order
     * @param {string} id The ID of the order to update.
     * @param {UpdateOrderPayload} updateOrderPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderIdPatch(id: string, updateOrderPayload: UpdateOrderPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderIdPatch(id, updateOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of an order
     * @param {string} id The ID of the order to update.
     * @param {UpdateOrderStatusPayload} updateOrderStatusPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderIdStatusPatch(id: string, updateOrderStatusPayload: UpdateOrderStatusPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderIdStatusPatch(id, updateOrderStatusPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a vendor or their staff to verify an order for pickup by providing a 6-digit OTP. Upon successful verification, the order status is automatically transitioned. - If `deliveryMethod` is `customer_pickup`, status changes from `ready_for_pickup` to `picked_up_by_customer`. - If `deliveryMethod` is `delivery_person`, status changes from `ready_for_delivery` to `en_route`. 
     * @summary Verify order pickup with an OTP
     * @param {string} id The ID of the order to verify.
     * @param {OrderIdVerifyPickupPostRequest} orderIdVerifyPickupPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderIdVerifyPickupPost(id: string, orderIdVerifyPickupPostRequest: OrderIdVerifyPickupPostRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderIdVerifyPickupPost(id, orderIdVerifyPickupPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept a pending order
     * @param {string} orderId The ID of the order to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdAcceptPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline a pending order
     * @param {string} orderId The ID of the order to decline.
     * @param {DeclineOrderPayload} [declineOrderPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a customer to approve or reject a replacement suggested by the shopper.
     * @summary Respond to a suggested item replacement
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {RespondToReplacementPayload} respondToReplacementPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdItemsItemIdRespondToReplacementPatch(orderId: string, itemId: string, respondToReplacementPayload: RespondToReplacementPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdItemsItemIdRespondToReplacementPatch(orderId, itemId, respondToReplacementPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
     * @summary Update the shopping status of an order item
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the conversation history for a specific order. The user must be a participant in the order (customer, shopper, or delivery person).
     * @summary Get messages for an order
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesGet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdMessagesGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message from the authenticated user to another participant (customer, shopper, or delivery person) of the order.
     * @summary Send a message related to an order
     * @param {string} orderId The ID of the order.
     * @param {OrderOrderIdMessagesPostRequest} orderOrderIdMessagesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesPost(orderId: string, orderOrderIdMessagesPostRequest: OrderOrderIdMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdMessagesPost(orderId, orderOrderIdMessagesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks all unread messages for the authenticated user within a specific order as read. This is typically called when the user opens the chat screen.
     * @summary Mark messages as read
     * @param {string} orderId The ID of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdMessagesReadPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdMessagesReadPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as \'currently shopping\'
     * @param {string} orderId The ID of the order to start shopping for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a customer to add or update tips for the shopper and/or delivery person after an order has been placed. This will recalculate the order\'s total amount.
     * @summary Add or update a tip for an order
     * @param {string} orderId The ID of the order to add a tip to.
     * @param {UpdateTipPayload} updateTipPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdTipPatch(orderId: string, updateTipPayload: UpdateTipPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderOrderIdTipPatch(orderId, updateTipPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new order based on a payload sent from the client, which includes all order items and delivery details. This endpoint is used when the cart state is managed on the client-side.
     * @summary Create an order from a client payload
     * @param {CreateOrderClientPayload} createOrderClientPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderPost(createOrderClientPayload: CreateOrderClientPayload, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderPost(createOrderClientPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all orders for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderUserMeGet(options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderUserMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
     * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
     * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderVendorGet(vendorId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get orders for a vendor\'s dashboard
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderVendorOrdersGet(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs the current geographic coordinates of the delivery person for a specific order. This should be called periodically by the delivery person\'s application. Only the assigned delivery person for the order can post a location.
     * @summary Add a location point for a delivery person
     * @param {string} orderId The ID of the order being delivered.
     * @param {OrdersOrderIdDeliveryLocationPostRequest} ordersOrderIdDeliveryLocationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdDeliveryLocationPost(orderId: string, ordersOrderIdDeliveryLocationPostRequest: OrdersOrderIdDeliveryLocationPostRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).ordersOrderIdDeliveryLocationPost(orderId, ordersOrderIdDeliveryLocationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the historical path of the delivery person for a specific order. This can be used to display the route on a map. Accessible by the customer who placed the order, the assigned delivery person, or an admin.
     * @summary Get the delivery path for an order
     * @param {string} orderId The ID of the order to retrieve the path for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdDeliveryPathGet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).ordersOrderIdDeliveryPathGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminAllGet: async (name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (isAlcohol !== undefined) {
                localVarQueryParameter['isAlcohol'] = isAlcohol;
            }

            if (isAgeRestricted !== undefined) {
                localVarQueryParameter['isAgeRestricted'] = isAgeRestricted;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminProductIdVendorProductsGet: async (productId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('productAdminProductIdVendorProductsGet', 'productId', productId)
            const localVarPath = `/product/admin/{productId}/vendor-products`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBarcodeGet: async (barcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productBarcodeGet', 'barcode', barcode)
            const localVarPath = `/product/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (barcode !== undefined) {
                localVarQueryParameter['barcode'] = barcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdDelete', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a base product
         * @param {string} id The ID of the base product to update.
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdPatch: async (id: string, updateProductBasePayload: UpdateProductBasePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdPatch', 'id', id)
            // verify required parameter 'updateProductBasePayload' is not null or undefined
            assertParamExists('productIdPatch', 'updateProductBasePayload', updateProductBasePayload)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductBasePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdStatusPatch: async (id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productIdStatusPatch', 'id', id)
            // verify required parameter 'productIdStatusPatchRequest' is not null or undefined
            assertParamExists('productIdStatusPatch', 'productIdStatusPatchRequest', productIdStatusPatchRequest)
            const localVarPath = `/product/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productIdStatusPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost: async (createProductPayload: CreateProductPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductPayload' is not null or undefined
            assertParamExists('productPost', 'createProductPayload', createProductPayload)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagsIdsGet: async (tagIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagIds' is not null or undefined
            assertParamExists('productTagsIdsGet', 'tagIds', tagIds)
            const localVarPath = `/product/tags/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('productUserUserIdGet', 'userId', userId)
            const localVarPath = `/product/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodeGet: async (barcode: string, vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('productVendorBarcodeGet', 'barcode', barcode)
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('productVendorBarcodeGet', 'vendorId', vendorId)
            const localVarPath = `/product/vendor/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (barcode !== undefined) {
                localVarQueryParameter['barcode'] = barcode;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodePost: async (createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorProductWithBarcodePayload' is not null or undefined
            assertParamExists('productVendorBarcodePost', 'createVendorProductWithBarcodePayload', createVendorProductWithBarcodePayload)
            const localVarPath = `/product/vendor/barcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorProductWithBarcodePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorCategoryGet: async (vendorId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('productVendorCategoryGet', 'vendorId', vendorId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('productVendorCategoryGet', 'categoryId', categoryId)
            const localVarPath = `/product/vendor/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorGet: async (name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdDelete', 'id', id)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdGet', 'id', id)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {string} id The ID of the vendor product to update.
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdPatch: async (id: string, updateVendorProductPayload: UpdateVendorProductPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productVendorIdPatch', 'id', id)
            // verify required parameter 'updateVendorProductPayload' is not null or undefined
            assertParamExists('productVendorIdPatch', 'updateVendorProductPayload', updateVendorProductPayload)
            const localVarPath = `/product/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/my-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorPost: async (createVendorProductPayload: CreateVendorProductPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorProductPayload' is not null or undefined
            assertParamExists('productVendorPost', 'createVendorProductPayload', createVendorProductPayload)
            const localVarPath = `/product/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorProductPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTagsIdsGet: async (tagIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagIds' is not null or undefined
            assertParamExists('productVendorTagsIdsGet', 'tagIds', tagIds)
            const localVarPath = `/product/vendor/tags/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost: async (productVendorTransferPostRequest: ProductVendorTransferPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productVendorTransferPostRequest' is not null or undefined
            assertParamExists('productVendorTransferPost', 'productVendorTransferPostRequest', productVendorTransferPostRequest)
            const localVarPath = `/product/vendor/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productVendorTransferPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductOverview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAdminProductIdVendorProductsGet(productId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productAdminProductIdVendorProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productBarcodeGet(barcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productBarcodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a base product
         * @param {string} id The ID of the base product to update.
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdPatch(id: string, updateProductBasePayload: UpdateProductBasePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdPatch(id, updateProductBasePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIdStatusPatch(id, productIdStatusPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productPost(createProductPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagsIdsGet(tagIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productTagsIdsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUserUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productUserUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorBarcodeGet(barcode, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorBarcodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorBarcodePost(createVendorProductWithBarcodePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorBarcodePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorCategoryGet(vendorId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorCategoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {string} id The ID of the vendor product to update.
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorIdPatch(id: string, updateVendorProductPayload: UpdateVendorProductPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorIdPatch(id, updateVendorProductPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorMyProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorMyProductsGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorMyProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorPost(createVendorProductPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProductWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTagsIdsGet(tagIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorTagsIdsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorTransferPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTransferPost(productVendorTransferPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorTransferPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTrendingVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTrendingGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.productVendorTrendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
         * @summary Get all base products with filtering and pagination (Admin)
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [categoryId] Filter by a specific category ID.
         * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
         * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
         * @summary Get an overview of product data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<ProductOverview> {
            return localVarFp.productAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
         * @summary Get all vendor products for a specific base product (Admin)
         * @param {string} productId The ID of the base product.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productAdminProductIdVendorProductsGet(productId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a base product by its barcode
         * @param {string} barcode The barcode of the product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productBarcodeGet(barcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all base products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductWithRelations>> {
            return localVarFp.productGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a base product
         * @param {string} id The ID of the base product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a base product
         * @param {string} id The ID of the base product to update.
         * @param {UpdateProductBasePayload} updateProductBasePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdPatch(id: string, updateProductBasePayload: UpdateProductBasePayload, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productIdPatch(id, updateProductBasePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an admin to enable or disable a base product by setting its `isActive` flag.
         * @summary Update a base product\'s active status (Admin)
         * @param {string} id The ID of the base product to update.
         * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productIdStatusPatch(id, productIdStatusPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
         * @summary Create a base product
         * @param {CreateProductPayload} createProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig): AxiosPromise<ProductWithRelations> {
            return localVarFp.productPost(createProductPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get base products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductWithRelations>> {
            return localVarFp.productTagsIdsGet(tagIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProduct>> {
            return localVarFp.productUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor-specific product by barcode
         * @param {string} barcode The barcode of the product.
         * @param {string} vendorId The ID of the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorBarcodeGet(barcode, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
         * @summary Create a vendor product via barcode scan
         * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorBarcodePost(createVendorProductWithBarcodePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get vendor products by category
         * @param {string} vendorId The ID of the vendor.
         * @param {string} categoryId The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProductWithRelations>> {
            return localVarFp.productVendorCategoryGet(vendorId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all vendor products with filtering and pagination
         * @param {string} [name] Filter by product name (case-insensitive contains).
         * @param {string} [vendorId] Filter by vendor ID.
         * @param {string} [productId] Filter by base product ID.
         * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
         * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendorProducts> {
            return localVarFp.productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vendor-specific product
         * @param {string} id The ID of the vendor product to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProduct> {
            return localVarFp.productVendorIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor-specific product by its ID
         * @param {string} id The ID of the vendor product to find.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vendor-specific product
         * @param {string} id The ID of the vendor product to update.
         * @param {UpdateVendorProductPayload} updateVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorIdPatch(id: string, updateVendorProductPayload: UpdateVendorProductPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorIdPatch(id, updateVendorProductPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorMyProductsGet200Response> {
            return localVarFp.productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a product listing for a specific vendor.
         * @summary Create a vendor-specific product
         * @param {CreateVendorProductPayload} createVendorProductPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductWithRelations> {
            return localVarFp.productVendorPost(createVendorProductPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get vendor products by tag IDs
         * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProductWithRelations>> {
            return localVarFp.productVendorTagsIdsGet(tagIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorTransferPost200Response> {
            return localVarFp.productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
            return localVarFp.productVendorTrendingGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 */
export class ProductApi extends BaseAPI {
    /**
     * Retrieves a paginated list of all base products in the system. Each product includes a count of how many vendors are selling it.
     * @summary Get all base products with filtering and pagination (Admin)
     * @param {string} [name] Filter by product name (case-insensitive contains).
     * @param {string} [categoryId] Filter by a specific category ID.
     * @param {boolean} [isAlcohol] Filter for products that are alcoholic.
     * @param {boolean} [isAgeRestricted] Filter for products that are age-restricted.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminAllGet(name?: string, categoryId?: string, isAlcohol?: boolean, isAgeRestricted?: boolean, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productAdminAllGet(name, categoryId, isAlcohol, isAgeRestricted, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about products, such as the total number of base products and vendor product listings.
     * @summary Get an overview of product data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all vendor-specific listings for a given base product ID.
     * @summary Get all vendor products for a specific base product (Admin)
     * @param {string} productId The ID of the base product.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productAdminProductIdVendorProductsGet(productId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productAdminProductIdVendorProductsGet(productId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a base product by its barcode
     * @param {string} barcode The barcode of the product to find.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productBarcodeGet(barcode: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productBarcodeGet(barcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all base products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productGet(options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a base product
     * @param {string} id The ID of the base product to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a base product
     * @param {string} id The ID of the base product to update.
     * @param {UpdateProductBasePayload} updateProductBasePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdPatch(id: string, updateProductBasePayload: UpdateProductBasePayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productIdPatch(id, updateProductBasePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an admin to enable or disable a base product by setting its `isActive` flag.
     * @summary Update a base product\'s active status (Admin)
     * @param {string} id The ID of the base product to update.
     * @param {ProductIdStatusPatchRequest} productIdStatusPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productIdStatusPatch(id: string, productIdStatusPatchRequest: ProductIdStatusPatchRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productIdStatusPatch(id, productIdStatusPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new base product in the system. This is the generic version of a product, not tied to a specific vendor.
     * @summary Create a base product
     * @param {CreateProductPayload} createProductPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productPost(createProductPayload: CreateProductPayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productPost(createProductPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get base products by tag IDs
     * @param {Array<string>} tagIds An array of tag IDs to filter products by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productTagsIdsGet(tagIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
     * @summary Get all products from all vendors belonging to a user
     * @param {string} userId The ID of the user whose vendor products are to be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor-specific product by barcode
     * @param {string} barcode The barcode of the product.
     * @param {string} vendorId The ID of the vendor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorBarcodeGet(barcode: string, vendorId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorBarcodeGet(barcode, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a vendor product by scanning a barcode. If the base product doesn\'t exist, it\'s created first.
     * @summary Create a vendor product via barcode scan
     * @param {CreateVendorProductWithBarcodePayload} createVendorProductWithBarcodePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorBarcodePost(createVendorProductWithBarcodePayload: CreateVendorProductWithBarcodePayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorBarcodePost(createVendorProductWithBarcodePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get vendor products by category
     * @param {string} vendorId The ID of the vendor.
     * @param {string} categoryId The ID of the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorCategoryGet(vendorId: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorCategoryGet(vendorId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all vendor products with filtering and pagination
     * @param {string} [name] Filter by product name (case-insensitive contains).
     * @param {string} [vendorId] Filter by vendor ID.
     * @param {string} [productId] Filter by base product ID.
     * @param {Array<string>} [categoryIds] Filter by an array of category IDs.
     * @param {Array<string>} [tagIds] Filter by an array of tag IDs.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorGet(name?: string, vendorId?: string, productId?: string, categoryIds?: Array<string>, tagIds?: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorGet(name, vendorId, productId, categoryIds, tagIds, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vendor-specific product
     * @param {string} id The ID of the vendor product to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor-specific product by its ID
     * @param {string} id The ID of the vendor product to find.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vendor-specific product
     * @param {string} id The ID of the vendor product to update.
     * @param {UpdateVendorProductPayload} updateVendorProductPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorIdPatch(id: string, updateVendorProductPayload: UpdateVendorProductPayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorIdPatch(id, updateVendorProductPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
     * @summary Get all products from all stores owned by the authenticated vendor
     * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a product listing for a specific vendor.
     * @summary Create a vendor-specific product
     * @param {CreateVendorProductPayload} createVendorProductPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorPost(createVendorProductPayload: CreateVendorProductPayload, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorPost(createVendorProductPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get vendor products by tag IDs
     * @param {Array<string>} tagIds An array of tag IDs to filter vendor products by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTagsIdsGet(tagIds: Array<string>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorTagsIdsGet(tagIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
     * @summary Transfer a product listing from one store to others
     * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
     * @summary Get trending vendor products
     * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).productVendorTrendingGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RatingApi - axios parameter creator
 */
export const RatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calculates the average rating and total count of ratings for a specific vendor, shopper, or deliverer.
         * @summary Get aggregate rating for a vendor or user
         * @param {string} [ratedVendorId] The ID of the vendor to get aggregate ratings for.
         * @param {string} [ratedUserId] The ID of the user (shopper/deliverer) to get aggregate ratings for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsAggregateGet: async (ratedVendorId?: string, ratedUserId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ratings/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ratedVendorId !== undefined) {
                localVarQueryParameter['ratedVendorId'] = ratedVendorId;
            }

            if (ratedUserId !== undefined) {
                localVarQueryParameter['ratedUserId'] = ratedUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of ratings, with optional filters.
         * @summary Get a list of ratings
         * @param {string} [orderId] Filter ratings by a specific order ID.
         * @param {string} [raterId] Filter ratings by the user who submitted them.
         * @param {string} [ratedVendorId] Filter ratings for a specific vendor.
         * @param {string} [ratedUserId] Filter ratings for a specific user (shopper or deliverer).
         * @param {RatingType} [type] Filter by the type of rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGet: async (orderId?: string, raterId?: string, ratedVendorId?: string, ratedUserId?: string, type?: RatingType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (raterId !== undefined) {
                localVarQueryParameter['raterId'] = raterId;
            }

            if (ratedVendorId !== undefined) {
                localVarQueryParameter['ratedVendorId'] = ratedVendorId;
            }

            if (ratedUserId !== undefined) {
                localVarQueryParameter['ratedUserId'] = ratedUserId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a customer to delete their own rating.
         * @summary Delete a rating
         * @param {string} id The ID of the rating to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ratingsIdDelete', 'id', id)
            const localVarPath = `/ratings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single rating by ID
         * @param {string} id The ID of the rating to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ratingsIdGet', 'id', id)
            const localVarPath = `/ratings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a customer to update their own rating for an order.
         * @summary Update a rating
         * @param {string} id The ID of the rating to update.
         * @param {UpdateRatingPayload} updateRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdPatch: async (id: string, updateRatingPayload: UpdateRatingPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ratingsIdPatch', 'id', id)
            // verify required parameter 'updateRatingPayload' is not null or undefined
            assertParamExists('ratingsIdPatch', 'updateRatingPayload', updateRatingPayload)
            const localVarPath = `/ratings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRatingPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a customer to submit a rating for a completed order. The rating can be for a VENDOR, SHOPPER, or DELIVERER. A user can only submit one rating of each type per order.
         * @summary Create a new rating for an order
         * @param {CreateRatingPayload} createRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPost: async (createRatingPayload: CreateRatingPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRatingPayload' is not null or undefined
            assertParamExists('ratingsPost', 'createRatingPayload', createRatingPayload)
            const localVarPath = `/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRatingPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingApi - functional programming interface
 */
export const RatingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingApiAxiosParamCreator(configuration)
    return {
        /**
         * Calculates the average rating and total count of ratings for a specific vendor, shopper, or deliverer.
         * @summary Get aggregate rating for a vendor or user
         * @param {string} [ratedVendorId] The ID of the vendor to get aggregate ratings for.
         * @param {string} [ratedUserId] The ID of the user (shopper/deliverer) to get aggregate ratings for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsAggregateGet(ratedVendorId?: string, ratedUserId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingsAggregateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsAggregateGet(ratedVendorId, ratedUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsAggregateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of ratings, with optional filters.
         * @summary Get a list of ratings
         * @param {string} [orderId] Filter ratings by a specific order ID.
         * @param {string} [raterId] Filter ratings by the user who submitted them.
         * @param {string} [ratedVendorId] Filter ratings for a specific vendor.
         * @param {string} [ratedUserId] Filter ratings for a specific user (shopper or deliverer).
         * @param {RatingType} [type] Filter by the type of rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsGet(orderId?: string, raterId?: string, ratedVendorId?: string, ratedUserId?: string, type?: RatingType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RatingWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsGet(orderId, raterId, ratedVendorId, ratedUserId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a customer to delete their own rating.
         * @summary Delete a rating
         * @param {string} id The ID of the rating to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single rating by ID
         * @param {string} id The ID of the rating to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a customer to update their own rating for an order.
         * @summary Update a rating
         * @param {string} id The ID of the rating to update.
         * @param {UpdateRatingPayload} updateRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsIdPatch(id: string, updateRatingPayload: UpdateRatingPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsIdPatch(id, updateRatingPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a customer to submit a rating for a completed order. The rating can be for a VENDOR, SHOPPER, or DELIVERER. A user can only submit one rating of each type per order.
         * @summary Create a new rating for an order
         * @param {CreateRatingPayload} createRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ratingsPost(createRatingPayload: CreateRatingPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rating>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ratingsPost(createRatingPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RatingApi.ratingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RatingApi - factory interface
 */
export const RatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingApiFp(configuration)
    return {
        /**
         * Calculates the average rating and total count of ratings for a specific vendor, shopper, or deliverer.
         * @summary Get aggregate rating for a vendor or user
         * @param {string} [ratedVendorId] The ID of the vendor to get aggregate ratings for.
         * @param {string} [ratedUserId] The ID of the user (shopper/deliverer) to get aggregate ratings for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsAggregateGet(ratedVendorId?: string, ratedUserId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RatingsAggregateGet200Response> {
            return localVarFp.ratingsAggregateGet(ratedVendorId, ratedUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of ratings, with optional filters.
         * @summary Get a list of ratings
         * @param {string} [orderId] Filter ratings by a specific order ID.
         * @param {string} [raterId] Filter ratings by the user who submitted them.
         * @param {string} [ratedVendorId] Filter ratings for a specific vendor.
         * @param {string} [ratedUserId] Filter ratings for a specific user (shopper or deliverer).
         * @param {RatingType} [type] Filter by the type of rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsGet(orderId?: string, raterId?: string, ratedVendorId?: string, ratedUserId?: string, type?: RatingType, options?: RawAxiosRequestConfig): AxiosPromise<Array<RatingWithRelations>> {
            return localVarFp.ratingsGet(orderId, raterId, ratedVendorId, ratedUserId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a customer to delete their own rating.
         * @summary Delete a rating
         * @param {string} id The ID of the rating to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Rating> {
            return localVarFp.ratingsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single rating by ID
         * @param {string} id The ID of the rating to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Rating> {
            return localVarFp.ratingsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a customer to update their own rating for an order.
         * @summary Update a rating
         * @param {string} id The ID of the rating to update.
         * @param {UpdateRatingPayload} updateRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsIdPatch(id: string, updateRatingPayload: UpdateRatingPayload, options?: RawAxiosRequestConfig): AxiosPromise<Rating> {
            return localVarFp.ratingsIdPatch(id, updateRatingPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a customer to submit a rating for a completed order. The rating can be for a VENDOR, SHOPPER, or DELIVERER. A user can only submit one rating of each type per order.
         * @summary Create a new rating for an order
         * @param {CreateRatingPayload} createRatingPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingsPost(createRatingPayload: CreateRatingPayload, options?: RawAxiosRequestConfig): AxiosPromise<Rating> {
            return localVarFp.ratingsPost(createRatingPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatingApi - object-oriented interface
 */
export class RatingApi extends BaseAPI {
    /**
     * Calculates the average rating and total count of ratings for a specific vendor, shopper, or deliverer.
     * @summary Get aggregate rating for a vendor or user
     * @param {string} [ratedVendorId] The ID of the vendor to get aggregate ratings for.
     * @param {string} [ratedUserId] The ID of the user (shopper/deliverer) to get aggregate ratings for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsAggregateGet(ratedVendorId?: string, ratedUserId?: string, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsAggregateGet(ratedVendorId, ratedUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of ratings, with optional filters.
     * @summary Get a list of ratings
     * @param {string} [orderId] Filter ratings by a specific order ID.
     * @param {string} [raterId] Filter ratings by the user who submitted them.
     * @param {string} [ratedVendorId] Filter ratings for a specific vendor.
     * @param {string} [ratedUserId] Filter ratings for a specific user (shopper or deliverer).
     * @param {RatingType} [type] Filter by the type of rating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsGet(orderId?: string, raterId?: string, ratedVendorId?: string, ratedUserId?: string, type?: RatingType, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsGet(orderId, raterId, ratedVendorId, ratedUserId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a customer to delete their own rating.
     * @summary Delete a rating
     * @param {string} id The ID of the rating to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single rating by ID
     * @param {string} id The ID of the rating to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a customer to update their own rating for an order.
     * @summary Update a rating
     * @param {string} id The ID of the rating to update.
     * @param {UpdateRatingPayload} updateRatingPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsIdPatch(id: string, updateRatingPayload: UpdateRatingPayload, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsIdPatch(id, updateRatingPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a customer to submit a rating for a completed order. The rating can be for a VENDOR, SHOPPER, or DELIVERER. A user can only submit one rating of each type per order.
     * @summary Create a new rating for an order
     * @param {CreateRatingPayload} createRatingPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ratingsPost(createRatingPayload: CreateRatingPayload, options?: RawAxiosRequestConfig) {
        return RatingApiFp(this.configuration).ratingsPost(createRatingPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StaffApi - axios parameter creator
 */
export const StaffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStaffIdGet: async (staffId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('staffAdminStaffIdGet', 'staffId', staffId)
            const localVarPath = `/staff/admin/{staffId}`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStoreVendorIdGet: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('staffAdminStoreVendorIdGet', 'vendorId', vendorId)
            const localVarPath = `/staff/admin/store/{vendorId}`
                .replace(`{${"vendorId"}}`, encodeURIComponent(String(vendorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of staff members with role-based access control: - **Vendor**: Can see all staff members across all of their stores. Can filter by a specific `vendorId` they own. - **Store Admin**: Can only see staff members from their assigned store. The `vendorId` filter is ignored. - **Store Shopper**: Not authorized to use this endpoint. 
         * @summary List staff members based on user role
         * @param {string} [vendorId] Optional. For Vendors, filters staff by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new staff member (shopper) for a vendor
         * @param {StaffPostRequest} staffPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffPost: async (staffPostRequest: StaffPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffPostRequest' is not null or undefined
            assertParamExists('staffPost', 'staffPostRequest', staffPostRequest)
            const localVarPath = `/staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a staff member\'s account
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdDelete: async (staffId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('staffStaffIdDelete', 'staffId', staffId)
            const localVarPath = `/staff/{staffId}`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single staff member by ID
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdGet: async (staffId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('staffStaffIdGet', 'staffId', staffId)
            const localVarPath = `/staff/{staffId}`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a staff member\'s details
         * @param {string} staffId 
         * @param {StaffStaffIdPatchRequest} staffStaffIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdPatch: async (staffId: string, staffStaffIdPatchRequest: StaffStaffIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'staffId' is not null or undefined
            assertParamExists('staffStaffIdPatch', 'staffId', staffId)
            // verify required parameter 'staffStaffIdPatchRequest' is not null or undefined
            assertParamExists('staffStaffIdPatch', 'staffStaffIdPatchRequest', staffStaffIdPatchRequest)
            const localVarPath = `/staff/{staffId}`
                .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staffStaffIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all staff members for a specific store
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStoreVendorIdGet: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('staffStoreVendorIdGet', 'vendorId', vendorId)
            const localVarPath = `/staff/store/{vendorId}`
                .replace(`{${"vendorId"}}`, encodeURIComponent(String(vendorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffTransactionsGet: async (staffUserId?: string, vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staff/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (staffUserId !== undefined) {
                localVarQueryParameter['staffUserId'] = staffUserId;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaffApi - functional programming interface
 */
export const StaffApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaffApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffAdminStaffIdGet(staffId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffAdminStaffIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffAdminStoreVendorIdGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffAdminStoreVendorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of staff members with role-based access control: - **Vendor**: Can see all staff members across all of their stores. Can filter by a specific `vendorId` they own. - **Store Admin**: Can only see staff members from their assigned store. The `vendorId` filter is ignored. - **Store Shopper**: Not authorized to use this endpoint. 
         * @summary List staff members based on user role
         * @param {string} [vendorId] Optional. For Vendors, filters staff by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new staff member (shopper) for a vendor
         * @param {StaffPostRequest} staffPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffPost(staffPostRequest: StaffPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffPost(staffPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a staff member\'s account
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffStaffIdDelete(staffId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffStaffIdDelete(staffId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffStaffIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single staff member by ID
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffStaffIdGet(staffId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffStaffIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a staff member\'s details
         * @param {string} staffId 
         * @param {StaffStaffIdPatchRequest} staffStaffIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffStaffIdPatch(staffId: string, staffStaffIdPatchRequest: StaffStaffIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffStaffIdPatch(staffId, staffStaffIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffStaffIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all staff members for a specific store
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffStoreVendorIdGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffStoreVendorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffTransactionsGet(staffUserId, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StaffApi.staffTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StaffApi - factory interface
 */
export const StaffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaffApiFp(configuration)
    return {
        /**
         * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
         * @summary Get a single staff member by ID (Admin)
         * @param {string} staffId The user ID of the staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffAdminStaffIdGet(staffId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
         * @summary List all staff for a specific store (Admin)
         * @param {string} vendorId The ID of the store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffAdminStoreVendorIdGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of staff members with role-based access control: - **Vendor**: Can see all staff members across all of their stores. Can filter by a specific `vendorId` they own. - **Store Admin**: Can only see staff members from their assigned store. The `vendorId` filter is ignored. - **Store Shopper**: Not authorized to use this endpoint. 
         * @summary List staff members based on user role
         * @param {string} [vendorId] Optional. For Vendors, filters staff by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new staff member (shopper) for a vendor
         * @param {StaffPostRequest} staffPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffPost(staffPostRequest: StaffPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffPost(staffPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a staff member\'s account
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdDelete(staffId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffStaffIdDelete(staffId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single staff member by ID
         * @param {string} staffId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdGet(staffId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffStaffIdGet(staffId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a staff member\'s details
         * @param {string} staffId 
         * @param {StaffStaffIdPatchRequest} staffStaffIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStaffIdPatch(staffId: string, staffStaffIdPatchRequest: StaffStaffIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffStaffIdPatch(staffId, staffStaffIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all staff members for a specific store
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffStoreVendorIdGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffTransactionsGet(staffUserId, vendorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaffApi - object-oriented interface
 */
export class StaffApi extends BaseAPI {
    /**
     * Retrieves the details of a specific staff member by their user ID. Only accessible by admins.
     * @summary Get a single staff member by ID (Admin)
     * @param {string} staffId The user ID of the staff member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffAdminStaffIdGet(staffId: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffAdminStaffIdGet(staffId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all staff members (store_admin, store_shopper) for a given store ID. Only accessible by admins.
     * @summary List all staff for a specific store (Admin)
     * @param {string} vendorId The ID of the store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffAdminStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffAdminStoreVendorIdGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of staff members with role-based access control: - **Vendor**: Can see all staff members across all of their stores. Can filter by a specific `vendorId` they own. - **Store Admin**: Can only see staff members from their assigned store. The `vendorId` filter is ignored. - **Store Shopper**: Not authorized to use this endpoint. 
     * @summary List staff members based on user role
     * @param {string} [vendorId] Optional. For Vendors, filters staff by a specific store ID. Ignored for other roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new staff member (shopper) for a vendor
     * @param {StaffPostRequest} staffPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffPost(staffPostRequest: StaffPostRequest, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffPost(staffPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a staff member\'s account
     * @param {string} staffId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffStaffIdDelete(staffId: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffStaffIdDelete(staffId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single staff member by ID
     * @param {string} staffId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffStaffIdGet(staffId: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffStaffIdGet(staffId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a staff member\'s details
     * @param {string} staffId 
     * @param {StaffStaffIdPatchRequest} staffStaffIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffStaffIdPatch(staffId: string, staffStaffIdPatchRequest: StaffStaffIdPatchRequest, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffStaffIdPatch(staffId, staffStaffIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all staff members for a specific store
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffStoreVendorIdGet(vendorId: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffStoreVendorIdGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
     * @summary List all transactions for a vendor\'s staff
     * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
     * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig) {
        return StaffApiFp(this.configuration).staffTransactionsGet(staffUserId, vendorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SupportApi - axios parameter creator
 */
export const SupportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsGet: async (customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all support tickets submitted by the authenticated user.
         * @summary Get my support tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/tickets/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows an authenticated user (customer, vendor, etc.) to submit a support ticket for issues or bugs.
         * @summary Create a new support ticket
         * @param {CreateSupportTicketPayload} createSupportTicketPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsPost: async (createSupportTicketPayload: CreateSupportTicketPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSupportTicketPayload' is not null or undefined
            assertParamExists('supportTicketsPost', 'createSupportTicketPayload', createSupportTicketPayload)
            const localVarPath = `/support/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSupportTicketPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific support ticket. Accessible by the user who created the ticket or an admin.
         * @summary Get a single support ticket by ID
         * @param {string} ticketId The ID of the support ticket to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdGet: async (ticketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportTicketsTicketIdGet', 'ticketId', ticketId)
            const localVarPath = `/support/tickets/{ticketId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdStatusPatch: async (ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportTicketsTicketIdStatusPatch', 'ticketId', ticketId)
            // verify required parameter 'updateSupportTicketStatusPayload' is not null or undefined
            assertParamExists('supportTicketsTicketIdStatusPatch', 'updateSupportTicketStatusPayload', updateSupportTicketStatusPayload)
            const localVarPath = `/support/tickets/{ticketId}/status`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupportTicketStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportApi - functional programming interface
 */
export const SupportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupportTickets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportTicketsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all support tickets submitted by the authenticated user.
         * @summary Get my support tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupportTicket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportTicketsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows an authenticated user (customer, vendor, etc.) to submit a support ticket for issues or bugs.
         * @summary Create a new support ticket
         * @param {CreateSupportTicketPayload} createSupportTicketPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsPost(createSupportTicketPayload: CreateSupportTicketPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsPost(createSupportTicketPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportTicketsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific support ticket. Accessible by the user who created the ticket or an admin.
         * @summary Get a single support ticket by ID
         * @param {string} ticketId The ID of the support ticket to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsTicketIdGet(ticketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsTicketIdGet(ticketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportTicketsTicketIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportTicketsTicketIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupportApi - factory interface
 */
export const SupportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportApiFp(configuration)
    return {
        /**
         * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
         * @summary Get platform-wide support ticket overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<SupportAdminOverviewGet200Response> {
            return localVarFp.supportAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all support tickets. Requires admin privileges.
         * @summary Get all support tickets (Admin)
         * @param {string} [customerName] Filter by customer name (case-insensitive).
         * @param {TicketStatus} [status] Filter by ticket status.
         * @param {string} [createdAtStart] Filter tickets created on or after this date.
         * @param {string} [createdAtEnd] Filter tickets created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedSupportTickets> {
            return localVarFp.supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all support tickets submitted by the authenticated user.
         * @summary Get my support tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SupportTicket>> {
            return localVarFp.supportTicketsMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Allows an authenticated user (customer, vendor, etc.) to submit a support ticket for issues or bugs.
         * @summary Create a new support ticket
         * @param {CreateSupportTicketPayload} createSupportTicketPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsPost(createSupportTicketPayload: CreateSupportTicketPayload, options?: RawAxiosRequestConfig): AxiosPromise<SupportTicket> {
            return localVarFp.supportTicketsPost(createSupportTicketPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific support ticket. Accessible by the user who created the ticket or an admin.
         * @summary Get a single support ticket by ID
         * @param {string} ticketId The ID of the support ticket to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdGet(ticketId: string, options?: RawAxiosRequestConfig): AxiosPromise<SupportTicket> {
            return localVarFp.supportTicketsTicketIdGet(ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of a specific support ticket. Requires admin privileges.
         * @summary Update a support ticket\'s status (Admin)
         * @param {string} ticketId 
         * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig): AxiosPromise<SupportTicket> {
            return localVarFp.supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportApi - object-oriented interface
 */
export class SupportApi extends BaseAPI {
    /**
     * Retrieves aggregate data about support tickets, such as total count, open tickets, and closed tickets. Only accessible by admins.
     * @summary Get platform-wide support ticket overview (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all support tickets. Requires admin privileges.
     * @summary Get all support tickets (Admin)
     * @param {string} [customerName] Filter by customer name (case-insensitive).
     * @param {TicketStatus} [status] Filter by ticket status.
     * @param {string} [createdAtStart] Filter tickets created on or after this date.
     * @param {string} [createdAtEnd] Filter tickets created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsGet(customerName?: string, status?: TicketStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportTicketsGet(customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all support tickets submitted by the authenticated user.
     * @summary Get my support tickets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsMeGet(options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportTicketsMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows an authenticated user (customer, vendor, etc.) to submit a support ticket for issues or bugs.
     * @summary Create a new support ticket
     * @param {CreateSupportTicketPayload} createSupportTicketPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsPost(createSupportTicketPayload: CreateSupportTicketPayload, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportTicketsPost(createSupportTicketPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific support ticket. Accessible by the user who created the ticket or an admin.
     * @summary Get a single support ticket by ID
     * @param {string} ticketId The ID of the support ticket to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsTicketIdGet(ticketId: string, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportTicketsTicketIdGet(ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of a specific support ticket. Requires admin privileges.
     * @summary Update a support ticket\'s status (Admin)
     * @param {string} ticketId 
     * @param {UpdateSupportTicketStatusPayload} updateSupportTicketStatusPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public supportTicketsTicketIdStatusPatch(ticketId: string, updateSupportTicketStatusPayload: UpdateSupportTicketStatusPayload, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportTicketsTicketIdStatusPatch(ticketId, updateSupportTicketStatusPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagApi - axios parameter creator
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create multiple tags in bulk
         * @param {CreateTagsBulkPayload} createTagsBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsBulkPost: async (createTagsBulkPayload: CreateTagsBulkPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagsBulkPayload' is not null or undefined
            assertParamExists('tagsBulkPost', 'createTagsBulkPayload', createTagsBulkPayload)
            const localVarPath = `/tags/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagsBulkPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all tags, with optional filtering by name
         * @param {string} [name] Filter tags by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} id The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagsIdDelete', 'id', id)
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a tag by its ID
         * @param {string} id The ID of the tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagsIdGet', 'id', id)
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a tag\'s name
         * @param {string} id The ID of the tag to update.
         * @param {UpdateTagPayload} updateTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdPatch: async (id: string, updateTagPayload: UpdateTagPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagsIdPatch', 'id', id)
            // verify required parameter 'updateTagPayload' is not null or undefined
            assertParamExists('tagsIdPatch', 'updateTagPayload', updateTagPayload)
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new tag
         * @param {CreateTagPayload} createTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (createTagPayload: CreateTagPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagPayload' is not null or undefined
            assertParamExists('tagsPost', 'createTagPayload', createTagPayload)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create multiple tags in bulk
         * @param {CreateTagsBulkPayload} createTagsBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsBulkPost(createTagsBulkPayload: CreateTagsBulkPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsBulkPost(createTagsBulkPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsBulkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all tags, with optional filtering by name
         * @param {string} [name] Filter tags by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} id The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a tag by its ID
         * @param {string} id The ID of the tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a tag\'s name
         * @param {string} id The ID of the tag to update.
         * @param {UpdateTagPayload} updateTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsIdPatch(id: string, updateTagPayload: UpdateTagPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsIdPatch(id, updateTagPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new tag
         * @param {CreateTagPayload} createTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(createTagPayload: CreateTagPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(createTagPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.tagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Create multiple tags in bulk
         * @param {CreateTagsBulkPayload} createTagsBulkPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsBulkPost(createTagsBulkPayload: CreateTagsBulkPayload, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.tagsBulkPost(createTagsBulkPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all tags, with optional filtering by name
         * @param {string} [name] Filter tags by name (case-insensitive search).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.tagsGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} id The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a tag by its ID
         * @param {string} id The ID of the tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a tag\'s name
         * @param {string} id The ID of the tag to update.
         * @param {UpdateTagPayload} updateTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdPatch(id: string, updateTagPayload: UpdateTagPayload, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsIdPatch(id, updateTagPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new tag
         * @param {CreateTagPayload} createTagPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(createTagPayload: CreateTagPayload, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPost(createTagPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Create multiple tags in bulk
     * @param {CreateTagsBulkPayload} createTagsBulkPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsBulkPost(createTagsBulkPayload: CreateTagsBulkPayload, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsBulkPost(createTagsBulkPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all tags, with optional filtering by name
     * @param {string} [name] Filter tags by name (case-insensitive search).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsGet(name?: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag
     * @param {string} id The ID of the tag to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a tag by its ID
     * @param {string} id The ID of the tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a tag\'s name
     * @param {string} id The ID of the tag to update.
     * @param {UpdateTagPayload} updateTagPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsIdPatch(id: string, updateTagPayload: UpdateTagPayload, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsIdPatch(id, updateTagPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new tag
     * @param {CreateTagPayload} createTagPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tagsPost(createTagPayload: CreateTagPayload, options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).tagsPost(createTagPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminAllGet: async (orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/admin/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderCode !== undefined) {
                localVarQueryParameter['orderCode'] = orderCode;
            }

            if (customerName !== undefined) {
                localVarQueryParameter['customerName'] = customerName;
            }

            if (status !== undefined) {
                for (const [key, value] of Object.entries(status)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/admin/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdGet: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('transactionsAdminTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/transactions/admin/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdSendReceiptPost: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('transactionsAdminTransactionIdSendReceiptPost', 'transactionId', transactionId)
            const localVarPath = `/transactions/admin/{transactionId}/send-receipt`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Payment Intent for an order
         * @param {TransactionsCreatePaymentIntentPostRequest} transactionsCreatePaymentIntentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsCreatePaymentIntentPost: async (transactionsCreatePaymentIntentPostRequest: TransactionsCreatePaymentIntentPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionsCreatePaymentIntentPostRequest' is not null or undefined
            assertParamExists('transactionsCreatePaymentIntentPost', 'transactionsCreatePaymentIntentPostRequest', transactionsCreatePaymentIntentPostRequest)
            const localVarPath = `/transactions/create-payment-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionsCreatePaymentIntentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get my saved payment methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMePaymentMethodsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/me/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a saved payment method
         * @param {string} paymentMethodId The Stripe PaymentMethod ID (pm_...).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMePaymentMethodsPaymentMethodIdDelete: async (paymentMethodId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('transactionsMePaymentMethodsPaymentMethodIdDelete', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/transactions/me/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Setup Intent to be used on the client-side for saving a new card for future use.
         * @summary Create a Setup Intent to save a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsSetupIntentPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/setup-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsAdminAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsAdminOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsAdminOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminTransactionIdGet(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsAdminTransactionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsAdminTransactionIdSendReceiptPost(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsAdminTransactionIdSendReceiptPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Payment Intent for an order
         * @param {TransactionsCreatePaymentIntentPostRequest} transactionsCreatePaymentIntentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest: TransactionsCreatePaymentIntentPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsCreatePaymentIntentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsCreatePaymentIntentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get my transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get my saved payment methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsMePaymentMethodsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedPaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsMePaymentMethodsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsMePaymentMethodsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a saved payment method
         * @param {string} paymentMethodId The Stripe PaymentMethod ID (pm_...).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsMePaymentMethodsPaymentMethodIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Setup Intent to be used on the client-side for saving a new card for future use.
         * @summary Create a Setup Intent to save a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsSetupIntentPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsCreatePaymentIntentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsSetupIntentPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsSetupIntentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsVendorGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionsVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
         * @summary Get a paginated list of all transactions (Admin)
         * @param {string} [orderCode] Filter by order code.
         * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
         * @param {TransactionStatus} [status] Filter by transaction status.
         * @param {string} [createdAtStart] Filter transactions created on or after this date.
         * @param {string} [createdAtEnd] Filter transactions created on or before this date.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
         * @summary Get platform-wide transaction overview (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<TransactionsAdminOverviewGet200Response> {
            return localVarFp.transactionsAdminOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
         * @summary Get a single transaction by ID (Admin)
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionWithRelations> {
            return localVarFp.transactionsAdminTransactionIdGet(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
         * @summary Generate and send a receipt for a transaction (Admin)
         * @param {string} transactionId The ID of the transaction to send a receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsAdminTransactionIdSendReceiptPost(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Payment Intent for an order
         * @param {TransactionsCreatePaymentIntentPostRequest} transactionsCreatePaymentIntentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest: TransactionsCreatePaymentIntentPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsCreatePaymentIntentPost200Response> {
            return localVarFp.transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionWithRelations>> {
            return localVarFp.transactionsMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get my saved payment methods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMePaymentMethodsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SavedPaymentMethod>> {
            return localVarFp.transactionsMePaymentMethodsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a saved payment method
         * @param {string} paymentMethodId The Stripe PaymentMethod ID (pm_...).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Setup Intent to be used on the client-side for saving a new card for future use.
         * @summary Create a Setup Intent to save a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsSetupIntentPost(options?: RawAxiosRequestConfig): AxiosPromise<TransactionsCreatePaymentIntentPost200Response> {
            return localVarFp.transactionsSetupIntentPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionWithRelations>> {
            return localVarFp.transactionsVendorGet(vendorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 */
export class TransactionApi extends BaseAPI {
    /**
     * Retrieves a paginated list of all transactions on the platform. Allows filtering by orderCode, customer name, status, and creation date. Only accessible by admins.
     * @summary Get a paginated list of all transactions (Admin)
     * @param {string} [orderCode] Filter by order code.
     * @param {string} [customerName] Filter by customer\&#39;s name (case-insensitive).
     * @param {TransactionStatus} [status] Filter by transaction status.
     * @param {string} [createdAtStart] Filter transactions created on or after this date.
     * @param {string} [createdAtEnd] Filter transactions created on or before this date.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminAllGet(orderCode?: string, customerName?: string, status?: TransactionStatus, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsAdminAllGet(orderCode, customerName, status, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate financial data for the platform, including total transactions, income (fees), expenses (refunds), and revenue. Only accessible by admins.
     * @summary Get platform-wide transaction overview (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminOverviewGet(options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsAdminOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the full details of a specific transaction by its ID. Only accessible by admins.
     * @summary Get a single transaction by ID (Admin)
     * @param {string} transactionId The ID of the transaction to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsAdminTransactionIdGet(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details for a transaction, generates an HTML receipt, and sends it to the customer\'s email address. Only accessible by admins.
     * @summary Generate and send a receipt for a transaction (Admin)
     * @param {string} transactionId The ID of the transaction to send a receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsAdminTransactionIdSendReceiptPost(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsAdminTransactionIdSendReceiptPost(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Payment Intent for an order
     * @param {TransactionsCreatePaymentIntentPostRequest} transactionsCreatePaymentIntentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest: TransactionsCreatePaymentIntentPostRequest, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsCreatePaymentIntentPost(transactionsCreatePaymentIntentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my transaction history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsMeGet(options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get my saved payment methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsMePaymentMethodsGet(options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsMePaymentMethodsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a saved payment method
     * @param {string} paymentMethodId The Stripe PaymentMethod ID (pm_...).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsMePaymentMethodsPaymentMethodIdDelete(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Setup Intent to be used on the client-side for saving a new card for future use.
     * @summary Create a Setup Intent to save a new payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsSetupIntentPost(options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsSetupIntentPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
     * @summary Get payment transactions for a vendor user
     * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionsVendorGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet: async (customerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersAdminCustomerIdTransactionsGet', 'customerId', customerId)
            const localVarPath = `/customers/admin/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerIdTransactionsGet: async (customerId: string, vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('customersCustomerIdTransactionsGet', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffTransactionsGet: async (staffUserId?: string, vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staff/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (staffUserId !== undefined) {
                localVarQueryParameter['staffUserId'] = staffUserId;
            }

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of transactions with role-based access control: - **Vendor**: Can see all transactions from all their stores. Can filter by `vendorId` (store ID) and `userId` (customer ID). - **Store Admin**: Can only see transactions from their assigned store. Can filter by `userId` (customer ID). - **Store Shopper**: Can only see transactions they have performed (e.g., payouts, tips). 
         * @summary List transactions based on user role
         * @param {string} [vendorId] Optional. (Vendor only) Filter transactions for a specific store.
         * @param {string} [userId] Optional. (Vendor/Store Admin) Filter transactions for a specific customer or staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: async (vendorId?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersAdminCustomerIdTransactionsGet(customerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.customersAdminCustomerIdTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersCustomerIdTransactionsGet(customerId, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.customersCustomerIdTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staffTransactionsGet(staffUserId, vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.staffTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of transactions with role-based access control: - **Vendor**: Can see all transactions from all their stores. Can filter by `vendorId` (store ID) and `userId` (customer ID). - **Store Admin**: Can only see transactions from their assigned store. Can filter by `userId` (customer ID). - **Store Shopper**: Can only see transactions they have performed (e.g., payouts, tips). 
         * @summary List transactions based on user role
         * @param {string} [vendorId] Optional. (Vendor only) Filter transactions for a specific store.
         * @param {string} [userId] Optional. (Vendor/Store Admin) Filter transactions for a specific customer or staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsGet(vendorId?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(vendorId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.transactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
         * @summary Get a paginated list of a customer\'s transactions (Admin)
         * @param {string} customerId The ID of the customer.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
         * @summary List all transactions for a specific customer
         * @param {string} customerId The ID of the customer.
         * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.customersCustomerIdTransactionsGet(customerId, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
         * @summary List all transactions for a vendor\'s staff
         * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
         * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.staffTransactionsGet(staffUserId, vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of transactions with role-based access control: - **Vendor**: Can see all transactions from all their stores. Can filter by `vendorId` (store ID) and `userId` (customer ID). - **Store Admin**: Can only see transactions from their assigned store. Can filter by `userId` (customer ID). - **Store Shopper**: Can only see transactions they have performed (e.g., payouts, tips). 
         * @summary List transactions based on user role
         * @param {string} [vendorId] Optional. (Vendor only) Filter transactions for a specific store.
         * @param {string} [userId] Optional. (Vendor/Store Admin) Filter transactions for a specific customer or staff member.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(vendorId?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionsGet(vendorId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Retrieves a paginated list of all transactions for a specific customer. Only accessible by admins.
     * @summary Get a paginated list of a customer\'s transactions (Admin)
     * @param {string} customerId The ID of the customer.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersAdminCustomerIdTransactionsGet(customerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).customersAdminCustomerIdTransactionsGet(customerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all transactions for a given customer, with role-based access: - **Vendor**: Can view all transactions for the customer across all their stores. Can optionally filter by a specific `vendorId` (store ID). - **Store Admin**: Can only view transactions for the customer within their assigned store. The `vendorId` filter is ignored. 
     * @summary List all transactions for a specific customer
     * @param {string} customerId The ID of the customer.
     * @param {string} [vendorId] Optional. For Vendors, filters transactions by a specific store ID. Ignored for other roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public customersCustomerIdTransactionsGet(customerId: string, vendorId?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).customersCustomerIdTransactionsGet(customerId, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of transactions performed by staff members, with role-based access: - **Vendor**: Can see transactions from all staff across all their stores. Can filter by `staffUserId` and/or `vendorId`. - **Store Admin**: Can only see transactions from staff in their assigned store. The `vendorId` filter is ignored if provided. 
     * @summary List all transactions for a vendor\'s staff
     * @param {string} [staffUserId] Optional. Filter transactions for a specific staff member (shopper or admin).
     * @param {string} [vendorId] Optional. For Vendors, filters transactions for staff at a specific store. For Store Admins, this is ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public staffTransactionsGet(staffUserId?: string, vendorId?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).staffTransactionsGet(staffUserId, vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of transactions with role-based access control: - **Vendor**: Can see all transactions from all their stores. Can filter by `vendorId` (store ID) and `userId` (customer ID). - **Store Admin**: Can only see transactions from their assigned store. Can filter by `userId` (customer ID). - **Store Shopper**: Can only see transactions they have performed (e.g., payouts, tips). 
     * @summary List transactions based on user role
     * @param {string} [vendorId] Optional. (Vendor only) Filter transactions for a specific store.
     * @param {string} [userId] Optional. (Vendor/Store Admin) Filter transactions for a specific customer or staff member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsGet(vendorId?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionsGet(vendorId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFcmTokenDelete: async (fcmToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fcmToken' is not null or undefined
            assertParamExists('devicesFcmTokenDelete', 'fcmToken', fcmToken)
            const localVarPath = `/devices/{fcmToken}`
                .replace(`{${"fcmToken"}}`, encodeURIComponent(String(fcmToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost: async (devicesPostRequest: DevicesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'devicesPostRequest' is not null or undefined
            assertParamExists('devicesPost', 'devicesPostRequest', devicesPostRequest)
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(devicesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('productUserUserIdGet', 'userId', userId)
            const localVarPath = `/product/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a paginated list of users
         * @param {boolean} [mobileVerified] Filter by mobile verification status.
         * @param {boolean} [active] Filter by active status.
         * @param {Role} [role] Filter by user role.
         * @param {string} [language] Filter by language.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (mobileVerified?: boolean, active?: boolean, role?: Role, language?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (mobileVerified !== undefined) {
                localVarQueryParameter['mobileVerified'] = mobileVerified;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id The ID of the user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by their ID
         * @param {string} id The ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user\'s details
         * @param {string} id The ID of the user to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, updateUserPayload: UpdateUserPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            // verify required parameter 'updateUserPayload' is not null or undefined
            assertParamExists('usersIdPut', 'updateUserPayload', updateUserPayload)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all stored verification codes. Intended for admin/debugging purposes.
         * @summary Get all verification codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersVerificationCodesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/verificationCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesFcmTokenDelete(fcmToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.devicesFcmTokenDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPost(devicesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.devicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUserUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.productUserUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a paginated list of users
         * @param {boolean} [mobileVerified] Filter by mobile verification status.
         * @param {boolean} [active] Filter by active status.
         * @param {Role} [role] Filter by user role.
         * @param {string} [language] Filter by language.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(mobileVerified?: boolean, active?: boolean, role?: Role, language?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(mobileVerified, active, role, language, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id The ID of the user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by their ID
         * @param {string} id The ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user\'s details
         * @param {string} id The ID of the user to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, updateUserPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all stored verification codes. Intended for admin/debugging purposes.
         * @summary Get all verification codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersVerificationCodesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Verification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersVerificationCodesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersVerificationCodesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Unregister a device for push notifications
         * @param {string} fcmToken The FCM token of the device to unregister.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.devicesFcmTokenDelete(fcmToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a device for push notifications
         * @param {DevicesPostRequest} devicesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.devicesPost(devicesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
         * @summary Get all products from all vendors belonging to a user
         * @param {string} userId The ID of the user whose vendor products are to be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProduct>> {
            return localVarFp.productUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a paginated list of users
         * @param {boolean} [mobileVerified] Filter by mobile verification status.
         * @param {boolean} [active] Filter by active status.
         * @param {Role} [role] Filter by user role.
         * @param {string} [language] Filter by language.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(mobileVerified?: boolean, active?: boolean, role?: Role, language?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedUsers> {
            return localVarFp.usersGet(mobileVerified, active, role, language, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id The ID of the user to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by their ID
         * @param {string} id The ID of the user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user\'s details
         * @param {string} id The ID of the user to update.
         * @param {UpdateUserPayload} updateUserPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdPut(id, updateUserPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all stored verification codes. Intended for admin/debugging purposes.
         * @summary Get all verification codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersVerificationCodesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Verification>> {
            return localVarFp.usersVerificationCodesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Unregister a device for push notifications
     * @param {string} fcmToken The FCM token of the device to unregister.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesFcmTokenDelete(fcmToken: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).devicesFcmTokenDelete(fcmToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a device for push notifications
     * @param {DevicesPostRequest} devicesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public devicesPost(devicesPostRequest: DevicesPostRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).devicesPost(devicesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendor-specific products from all stores owned by a particular user. This can be used by an admin or the user themselves.
     * @summary Get all products from all vendors belonging to a user
     * @param {string} userId The ID of the user whose vendor products are to be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productUserUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).productUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a paginated list of users
     * @param {boolean} [mobileVerified] Filter by mobile verification status.
     * @param {boolean} [active] Filter by active status.
     * @param {Role} [role] Filter by user role.
     * @param {string} [language] Filter by language.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersGet(mobileVerified?: boolean, active?: boolean, role?: Role, language?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersGet(mobileVerified, active, role, language, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} id The ID of the user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by their ID
     * @param {string} id The ID of the user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user\'s details
     * @param {string} id The ID of the user to update.
     * @param {UpdateUserPayload} updateUserPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersIdPut(id: string, updateUserPayload: UpdateUserPayload, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersIdPut(id, updateUserPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all stored verification codes. Intended for admin/debugging purposes.
     * @summary Get all verification codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersVerificationCodesGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersVerificationCodesGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('vendorsUsersUserIdGet', 'userId', userId)
            const localVarPath = `/vendors/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsUsersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.vendorsUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vendorsUsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
     * @summary Get a single vendor user by their User ID (Admin)
     * @param {string} userId The ID of the vendor user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).vendorsUsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VendorApi - axios parameter creator
 */
export const VendorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet: async (period?: EarningsTotalGetPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/earnings/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdAcceptPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/accept`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch: async (orderId: string, declineOrderPayload?: DeclineOrderPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdDeclinePatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/decline`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineOrderPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch: async (orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'orderId', orderId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'itemId', itemId)
            // verify required parameter 'updateOrderItemShoppingStatusPayload' is not null or undefined
            assertParamExists('orderOrderIdItemsItemIdUpdateShoppingStatusPatch', 'updateOrderItemShoppingStatusPayload', updateOrderItemShoppingStatusPayload)
            const localVarPath = `/order/{orderId}/items/{itemId}/update-shopping-status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderItemShoppingStatusPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderOrderIdStartShoppingPatch', 'orderId', orderId)
            const localVarPath = `/order/{orderId}/start-shopping`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet: async (vendorId?: string, status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet: async (status?: OrderStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/vendorOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/my-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost: async (productVendorTransferPostRequest: ProductVendorTransferPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productVendorTransferPostRequest' is not null or undefined
            assertParamExists('productVendorTransferPost', 'productVendorTransferPostRequest', productVendorTransferPostRequest)
            const localVarPath = `/product/vendor/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productVendorTransferPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet: async (vendorId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/vendor/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet: async (vendorId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {boolean} [isVerified] Filter vendors by their verification status.
         * @param {boolean} [isPublished] Filter vendors by their published status.
         * @param {string} [createdAtStart] Filter vendors created on or after this date (ISO 8601 format).
         * @param {string} [createdAtEnd] Filter vendors created on or before this date (ISO 8601 format).
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet: async (name?: string, latitude?: number, longitude?: number, userId?: string, isVerified?: boolean, isPublished?: boolean, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isVerified !== undefined) {
                localVarQueryParameter['isVerified'] = isVerified;
            }

            if (isPublished !== undefined) {
                localVarQueryParameter['isPublished'] = isPublished;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['createdAtStart'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['createdAtEnd'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/getvendorsby/userId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdApprovePatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdApprovePatch', 'id', id)
            const localVarPath = `/vendors/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a vendor\'s store as available or unavailable for shopping by setting `availableForShopping`. Only the user who owns the vendor can perform this action. 
         * @summary Set a vendor\'s shopping availability
         * @param {string} id The ID of the vendor to update.
         * @param {VendorsIdAvailabilityPatchRequest} vendorsIdAvailabilityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdAvailabilityPatch: async (id: string, vendorsIdAvailabilityPatchRequest: VendorsIdAvailabilityPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdAvailabilityPatch', 'id', id)
            // verify required parameter 'vendorsIdAvailabilityPatchRequest' is not null or undefined
            assertParamExists('vendorsIdAvailabilityPatch', 'vendorsIdAvailabilityPatchRequest', vendorsIdAvailabilityPatchRequest)
            const localVarPath = `/vendors/{id}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorsIdAvailabilityPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdDelete', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet: async (id: string, latitude?: number, longitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdGet', 'id', id)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {string} id The ID of the vendor to update.
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch: async (id: string, updateVendorPayload: UpdateVendorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdPatch', 'id', id)
            // verify required parameter 'updateVendorPayload' is not null or undefined
            assertParamExists('vendorsIdPatch', 'updateVendorPayload', updateVendorPayload)
            const localVarPath = `/vendors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPublishPatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('vendorsIdPublishPatch', 'id', id)
            const localVarPath = `/vendors/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIncompleteSetupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/incomplete-setups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vendors/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost: async (createVendorPayload: CreateVendorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVendorPayload' is not null or undefined
            assertParamExists('vendorsPost', 'createVendorPayload', createVendorPayload)
            const localVarPath = `/vendors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVendorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('vendorsUsersUserIdGet', 'userId', userId)
            const localVarPath = `/vendors/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorApi - functional programming interface
 */
export const VendorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.earningsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarningsTotalGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earningsTotalGet(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.earningsTotalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdAcceptPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdDeclinePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdItemsItemIdUpdateShoppingStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderOrderIdStartShoppingPatch(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderOrderIdStartShoppingPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorGet(vendorId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderVendorOrdersGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.orderVendorOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorMyProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorMyProductsGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorMyProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVendorTransferPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTransferPost(productVendorTransferPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorTransferPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTrendingVendorProducts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVendorTrendingGet(vendorId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.productVendorTrendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsVendorGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.transactionsVendorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {boolean} [isVerified] Filter vendors by their verification status.
         * @param {boolean} [isPublished] Filter vendors by their published status.
         * @param {string} [createdAtStart] Filter vendors created on or after this date (ISO 8601 format).
         * @param {string} [createdAtEnd] Filter vendors created on or before this date (ISO 8601 format).
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, isVerified?: boolean, isPublished?: boolean, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGet(name, latitude, longitude, userId, isVerified, isPublished, createdAtStart, createdAtEnd, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsGetvendorsbyUserIdGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsGetvendorsbyUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdApprovePatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdApprovePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a vendor\'s store as available or unavailable for shopping by setting `availableForShopping`. Only the user who owns the vendor can perform this action. 
         * @summary Set a vendor\'s shopping availability
         * @param {string} id The ID of the vendor to update.
         * @param {VendorsIdAvailabilityPatchRequest} vendorsIdAvailabilityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdAvailabilityPatch(id: string, vendorsIdAvailabilityPatchRequest: VendorsIdAvailabilityPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdAvailabilityPatch(id, vendorsIdAvailabilityPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdAvailabilityPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdGet(id, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {string} id The ID of the vendor to update.
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdPatch(id: string, updateVendorPayload: UpdateVendorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdPatch(id, updateVendorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIdPublishPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIdPublishPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorsIncompleteSetupsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsIncompleteSetupsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsIncompleteSetupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorsOverviewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsPost(createVendorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorsUsersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorApi.vendorsUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorApi - factory interface
 */
export const VendorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorApiFp(configuration)
    return {
        /**
         * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
         * @summary List earnings for a vendor
         * @param {string} [vendorId] Optional. Filter earnings for a specific store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.earningsGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
         * @summary Get total earnings for a vendor
         * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig): AxiosPromise<EarningsTotalGet200Response> {
            return localVarFp.earningsTotalGet(period, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept a pending order
         * @param {string} orderId The ID of the order to accept.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdAcceptPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Decline a pending order
         * @param {string} orderId The ID of the order to decline.
         * @param {DeclineOrderPayload} [declineOrderPayload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
         * @summary Update the shopping status of an order item
         * @param {string} orderId 
         * @param {string} itemId 
         * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig): AxiosPromise<OrderItemWithRelations> {
            return localVarFp.orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an order as \'currently shopping\'
         * @param {string} orderId The ID of the order to start shopping for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
         * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
         * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.orderVendorGet(vendorId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get orders for a vendor\'s dashboard
         * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOrder>> {
            return localVarFp.orderVendorOrdersGet(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
         * @summary Get all products from all stores owned by the authenticated vendor
         * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorMyProductsGet200Response> {
            return localVarFp.productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
         * @summary Transfer a product listing from one store to others
         * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductVendorTransferPost200Response> {
            return localVarFp.productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
         * @summary Get trending vendor products
         * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTrendingVendorProducts> {
            return localVarFp.productVendorTrendingGet(vendorId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
         * @summary Get payment transactions for a vendor user
         * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionWithRelations>> {
            return localVarFp.transactionsVendorGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
         * @summary Get a paginated list of vendors
         * @param {string} [name] Filter vendors by name (case-insensitive search).
         * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
         * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
         * @param {string} [userId] Filter vendors by the user who owns them.
         * @param {boolean} [isVerified] Filter vendors by their verification status.
         * @param {boolean} [isPublished] Filter vendors by their published status.
         * @param {string} [createdAtStart] Filter vendors created on or after this date (ISO 8601 format).
         * @param {string} [createdAtEnd] Filter vendors created on or before this date (ISO 8601 format).
         * @param {number} [page] Page number for pagination.
         * @param {number} [size] Number of items per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, isVerified?: boolean, isPublished?: boolean, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendors> {
            return localVarFp.vendorsGet(name, latitude, longitude, userId, isVerified, isPublished, createdAtStart, createdAtEnd, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all vendors associated with the currently authenticated user.
         * @summary Get all vendors for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorListItem>> {
            return localVarFp.vendorsGetvendorsbyUserIdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
         * @summary Approve a vendor\'s store (Admin)
         * @param {string} id The ID of the vendor to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.vendorsIdApprovePatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a vendor\'s store as available or unavailable for shopping by setting `availableForShopping`. Only the user who owns the vendor can perform this action. 
         * @summary Set a vendor\'s shopping availability
         * @param {string} id The ID of the vendor to update.
         * @param {VendorsIdAvailabilityPatchRequest} vendorsIdAvailabilityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdAvailabilityPatch(id: string, vendorsIdAvailabilityPatchRequest: VendorsIdAvailabilityPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vendorsIdAvailabilityPatch(id, vendorsIdAvailabilityPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vendor
         * @param {string} id The ID of the vendor to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a vendor by its ID
         * @param {string} id The ID of the vendor to retrieve.
         * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
         * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithDetails> {
            return localVarFp.vendorsIdGet(id, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a vendor\'s details
         * @param {string} id The ID of the vendor to update.
         * @param {UpdateVendorPayload} updateVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPatch(id: string, updateVendorPayload: UpdateVendorPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsIdPatch(id, updateVendorPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
         * @summary Publish a vendor\'s store
         * @param {string} id The ID of the vendor to publish.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.vendorsIdPublishPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
         * @summary Find vendors with incomplete setup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig): AxiosPromise<VendorsIncompleteSetupsGet200Response> {
            return localVarFp.vendorsIncompleteSetupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
         * @summary Get platform overview data (Admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<VendorsOverviewGet200Response> {
            return localVarFp.vendorsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
         * @summary Create a new vendor
         * @param {CreateVendorPayload} createVendorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorWithRelations> {
            return localVarFp.vendorsPost(createVendorPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
         * @summary Get a single vendor user by their User ID (Admin)
         * @param {string} userId The ID of the vendor user to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vendorsUsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VendorApi - object-oriented interface
 */
export class VendorApi extends BaseAPI {
    /**
     * Retrieves a list of all earnings (vendor payouts) for the authenticated vendor owner. Can be filtered by a specific `vendorId` (store ID) to see earnings for just one store. 
     * @summary List earnings for a vendor
     * @param {string} [vendorId] Optional. Filter earnings for a specific store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).earningsGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculates and returns the total earnings for the authenticated vendor owner. The total can be filtered by a specific time period. 
     * @summary Get total earnings for a vendor
     * @param {EarningsTotalGetPeriodEnum} [period] Optional. The time period to calculate earnings for. - &#x60;today&#x60;: From the beginning of the current day. - &#x60;7days&#x60;: For the last 7 days. - &#x60;1month&#x60;: For the last 1 month. - &#x60;1year&#x60;: For the last 1 year. If omitted, total earnings of all time are returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public earningsTotalGet(period?: EarningsTotalGetPeriodEnum, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).earningsTotalGet(period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept a pending order
     * @param {string} orderId The ID of the order to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdAcceptPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdAcceptPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Decline a pending order
     * @param {string} orderId The ID of the order to decline.
     * @param {DeclineOrderPayload} [declineOrderPayload] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdDeclinePatch(orderId: string, declineOrderPayload?: DeclineOrderPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdDeclinePatch(orderId, declineOrderPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the assigned shopper or delivery person to update an item\'s status during shopping (e.g., found, not found, suggest replacement).
     * @summary Update the shopping status of an order item
     * @param {string} orderId 
     * @param {string} itemId 
     * @param {UpdateOrderItemShoppingStatusPayload} updateOrderItemShoppingStatusPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId: string, itemId: string, updateOrderItemShoppingStatusPayload: UpdateOrderItemShoppingStatusPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdItemsItemIdUpdateShoppingStatusPatch(orderId, itemId, updateOrderItemShoppingStatusPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an order as \'currently shopping\'
     * @param {string} orderId The ID of the order to start shopping for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderOrderIdStartShoppingPatch(orderId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderOrderIdStartShoppingPatch(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of orders with role-based access: - **Vendor**: Can see all orders from all their stores. Can filter by `vendorId` and/or `status`. - **Store Admin**: Can only see orders from their assigned store. - **Store Shopper**: Can only see orders assigned to them (`shopperId` matches their user ID) within their store. 
     * @summary Get orders based on user role (Vendor, Store Admin, or Store Shopper)
     * @param {string} [vendorId] Optional. For Vendors, filters orders by a specific store ID. Ignored for staff roles.
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorGet(vendorId?: string, status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderVendorGet(vendorId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get orders for a vendor\'s dashboard
     * @param {OrderStatus} [status] Optional. Filter orders by a specific status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderVendorOrdersGet(status?: OrderStatus, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).orderVendorOrdersGet(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a complete list of all vendor-specific products from all stores owned by the authenticated vendor user.
     * @summary Get all products from all stores owned by the authenticated vendor
     * @param {string} [vendorId] Optional. Filter products by a specific store ID owned by the vendor.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorMyProductsGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorMyProductsGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copies a vendor product listing from a source store to one or more target stores owned by the same vendor. The product will not be transferred to stores where it already exists. 
     * @summary Transfer a product listing from one store to others
     * @param {ProductVendorTransferPostRequest} productVendorTransferPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTransferPost(productVendorTransferPostRequest: ProductVendorTransferPostRequest, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorTransferPost(productVendorTransferPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendor products that are trending, based on the number of times they have been ordered.
     * @summary Get trending vendor products
     * @param {string} [vendorId] Optional. Filter trending products by a specific vendor ID.
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productVendorTrendingGet(vendorId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).productVendorTrendingGet(vendorId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all payment-related transactions for stores owned by the authenticated vendor user. Can be filtered by a specific store.
     * @summary Get payment transactions for a vendor user
     * @param {string} [vendorId] Optional. The ID of a specific store (vendor) to filter payments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transactionsVendorGet(vendorId?: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).transactionsVendorGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendors. Can be filtered by name and sorted by proximity if latitude and longitude are provided. If the user is authenticated, it also returns the number of items in their cart for each vendor.
     * @summary Get a paginated list of vendors
     * @param {string} [name] Filter vendors by name (case-insensitive search).
     * @param {number} [latitude] User\&#39;s current latitude to sort vendors by distance.
     * @param {number} [longitude] User\&#39;s current longitude to sort vendors by distance.
     * @param {string} [userId] Filter vendors by the user who owns them.
     * @param {boolean} [isVerified] Filter vendors by their verification status.
     * @param {boolean} [isPublished] Filter vendors by their published status.
     * @param {string} [createdAtStart] Filter vendors created on or after this date (ISO 8601 format).
     * @param {string} [createdAtEnd] Filter vendors created on or before this date (ISO 8601 format).
     * @param {number} [page] Page number for pagination.
     * @param {number} [size] Number of items per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGet(name?: string, latitude?: number, longitude?: number, userId?: string, isVerified?: boolean, isPublished?: boolean, createdAtStart?: string, createdAtEnd?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsGet(name, latitude, longitude, userId, isVerified, isPublished, createdAtStart, createdAtEnd, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all vendors associated with the currently authenticated user.
     * @summary Get all vendors for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsGetvendorsbyUserIdGet(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsGetvendorsbyUserIdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a vendor\'s store as verified by setting `isVerified` to true. This is intended to be an admin-only action. 
     * @summary Approve a vendor\'s store (Admin)
     * @param {string} id The ID of the vendor to approve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdApprovePatch(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdApprovePatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a vendor\'s store as available or unavailable for shopping by setting `availableForShopping`. Only the user who owns the vendor can perform this action. 
     * @summary Set a vendor\'s shopping availability
     * @param {string} id The ID of the vendor to update.
     * @param {VendorsIdAvailabilityPatchRequest} vendorsIdAvailabilityPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdAvailabilityPatch(id: string, vendorsIdAvailabilityPatchRequest: VendorsIdAvailabilityPatchRequest, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdAvailabilityPatch(id, vendorsIdAvailabilityPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vendor
     * @param {string} id The ID of the vendor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a vendor by its ID
     * @param {string} id The ID of the vendor to retrieve.
     * @param {number} [latitude] User\&#39;s current latitude to calculate distance to the vendor.
     * @param {number} [longitude] User\&#39;s current longitude to calculate distance to the vendor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdGet(id: string, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdGet(id, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a vendor\'s details
     * @param {string} id The ID of the vendor to update.
     * @param {UpdateVendorPayload} updateVendorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdPatch(id: string, updateVendorPayload: UpdateVendorPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdPatch(id, updateVendorPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks a vendor\'s store as published by setting `isPublished` to true, making it visible to customers. Only the user who owns the vendor can perform this action. 
     * @summary Publish a vendor\'s store
     * @param {string} id The ID of the vendor to publish.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIdPublishPatch(id: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIdPublishPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of vendors for the authenticated user that have not completed their setup. A setup is considered incomplete if the vendor has either not added any products OR has uploaded fewer than two documents. 
     * @summary Find vendors with incomplete setup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsIncompleteSetupsGet(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsIncompleteSetupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregate data about the platform, such as the total number of vendor users, stores, and staff members. Only accessible by admins.
     * @summary Get platform overview data (Admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsOverviewGet(options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new vendor profile linked to the authenticated user. Default opening hours from 9:00 to 18:00 are created automatically for all days of the week.
     * @summary Create a new vendor
     * @param {CreateVendorPayload} createVendorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsPost(createVendorPayload: CreateVendorPayload, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsPost(createVendorPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a specific user who has the \'vendor\' role. Intended for admin use.
     * @summary Get a single vendor user by their User ID (Admin)
     * @param {string} userId The ID of the vendor user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public vendorsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return VendorApiFp(this.configuration).vendorsUsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const EarningsTotalGetPeriodEnum = {
    Today: 'today',
    _7days: '7days',
    _1month: '1month',
    _1year: '1year'
} as const;
export type EarningsTotalGetPeriodEnum = typeof EarningsTotalGetPeriodEnum[keyof typeof EarningsTotalGetPeriodEnum];


/**
 * VendorOpeningHoursApi - axios parameter creator
 */
export const VendorOpeningHoursApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all opening hours for a specific vendor
         * @param {string} vendorId The ID of the vendor to retrieve opening hours for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openingHoursGet: async (vendorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('openingHoursGet', 'vendorId', vendorId)
            const localVarPath = `/openingHours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (vendorId !== undefined) {
                localVarQueryParameter['vendorId'] = vendorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds and updates the opening and closing times for a given vendor on a specific day of the week.
         * @summary Update opening hours for a specific day
         * @param {UpdateOpeningHoursPayload} updateOpeningHoursPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openingHoursPatch: async (updateOpeningHoursPayload: UpdateOpeningHoursPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOpeningHoursPayload' is not null or undefined
            assertParamExists('openingHoursPatch', 'updateOpeningHoursPayload', updateOpeningHoursPayload)
            const localVarPath = `/openingHours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOpeningHoursPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VendorOpeningHoursApi - functional programming interface
 */
export const VendorOpeningHoursApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VendorOpeningHoursApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all opening hours for a specific vendor
         * @param {string} vendorId The ID of the vendor to retrieve opening hours for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openingHoursGet(vendorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorOpeningHours>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openingHoursGet(vendorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorOpeningHoursApi.openingHoursGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finds and updates the opening and closing times for a given vendor on a specific day of the week.
         * @summary Update opening hours for a specific day
         * @param {UpdateOpeningHoursPayload} updateOpeningHoursPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openingHoursPatch(updateOpeningHoursPayload: UpdateOpeningHoursPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorOpeningHours>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openingHoursPatch(updateOpeningHoursPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VendorOpeningHoursApi.openingHoursPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VendorOpeningHoursApi - factory interface
 */
export const VendorOpeningHoursApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VendorOpeningHoursApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all opening hours for a specific vendor
         * @param {string} vendorId The ID of the vendor to retrieve opening hours for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openingHoursGet(vendorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorOpeningHours>> {
            return localVarFp.openingHoursGet(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds and updates the opening and closing times for a given vendor on a specific day of the week.
         * @summary Update opening hours for a specific day
         * @param {UpdateOpeningHoursPayload} updateOpeningHoursPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openingHoursPatch(updateOpeningHoursPayload: UpdateOpeningHoursPayload, options?: RawAxiosRequestConfig): AxiosPromise<VendorOpeningHours> {
            return localVarFp.openingHoursPatch(updateOpeningHoursPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VendorOpeningHoursApi - object-oriented interface
 */
export class VendorOpeningHoursApi extends BaseAPI {
    /**
     * 
     * @summary Get all opening hours for a specific vendor
     * @param {string} vendorId The ID of the vendor to retrieve opening hours for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public openingHoursGet(vendorId: string, options?: RawAxiosRequestConfig) {
        return VendorOpeningHoursApiFp(this.configuration).openingHoursGet(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds and updates the opening and closing times for a given vendor on a specific day of the week.
     * @summary Update opening hours for a specific day
     * @param {UpdateOpeningHoursPayload} updateOpeningHoursPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public openingHoursPatch(updateOpeningHoursPayload: UpdateOpeningHoursPayload, options?: RawAxiosRequestConfig) {
        return VendorOpeningHoursApiFp(this.configuration).openingHoursPatch(updateOpeningHoursPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the wallet details and balance for the currently authenticated user. If a wallet does not exist, it will be created automatically.
         * @summary Get the authenticated user\'s wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all financial transactions for the authenticated user.
         * @summary Get the authenticated user\'s transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletMeTransactionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/me/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the wallet details and balance for the currently authenticated user. If a wallet does not exist, it will be created automatically.
         * @summary Get the authenticated user\'s wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all financial transactions for the authenticated user.
         * @summary Get the authenticated user\'s transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletMeTransactionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletMeTransactionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletMeTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Retrieves the wallet details and balance for the currently authenticated user. If a wallet does not exist, it will be created automatically.
         * @summary Get the authenticated user\'s wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.walletMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all financial transactions for the authenticated user.
         * @summary Get the authenticated user\'s transaction history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletMeTransactionsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionWithRelations>> {
            return localVarFp.walletMeTransactionsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 */
export class WalletApi extends BaseAPI {
    /**
     * Retrieves the wallet details and balance for the currently authenticated user. If a wallet does not exist, it will be created automatically.
     * @summary Get the authenticated user\'s wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletMeGet(options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all financial transactions for the authenticated user.
     * @summary Get the authenticated user\'s transaction history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletMeTransactionsGet(options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletMeTransactionsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WishlistApi - axios parameter creator
 */
export const WishlistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the user\'s wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from the wishlist
         * @param {string} id The ID of the wishlist item to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('wishlistIdDelete', 'id', id)
            const localVarPath = `/wishlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a product to the wishlist
         * @param {CreateWishlistItemPayload} createWishlistItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistPost: async (createWishlistItemPayload: CreateWishlistItemPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWishlistItemPayload' is not null or undefined
            assertParamExists('wishlistPost', 'createWishlistItemPayload', createWishlistItemPayload)
            const localVarPath = `/wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWishlistItemPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WishlistApi - functional programming interface
 */
export const WishlistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WishlistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the user\'s wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wishlistGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WishlistItemWithRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wishlistGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WishlistApi.wishlistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from the wishlist
         * @param {string} id The ID of the wishlist item to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wishlistIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WishlistItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wishlistIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WishlistApi.wishlistIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a product to the wishlist
         * @param {CreateWishlistItemPayload} createWishlistItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wishlistPost(createWishlistItemPayload: CreateWishlistItemPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WishlistItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wishlistPost(createWishlistItemPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WishlistApi.wishlistPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WishlistApi - factory interface
 */
export const WishlistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WishlistApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the user\'s wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<WishlistItemWithRelations>> {
            return localVarFp.wishlistGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from the wishlist
         * @param {string} id The ID of the wishlist item to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WishlistItem> {
            return localVarFp.wishlistIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a product to the wishlist
         * @param {CreateWishlistItemPayload} createWishlistItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wishlistPost(createWishlistItemPayload: CreateWishlistItemPayload, options?: RawAxiosRequestConfig): AxiosPromise<WishlistItem> {
            return localVarFp.wishlistPost(createWishlistItemPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WishlistApi - object-oriented interface
 */
export class WishlistApi extends BaseAPI {
    /**
     * 
     * @summary Get the user\'s wishlist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public wishlistGet(options?: RawAxiosRequestConfig) {
        return WishlistApiFp(this.configuration).wishlistGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from the wishlist
     * @param {string} id The ID of the wishlist item to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public wishlistIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WishlistApiFp(this.configuration).wishlistIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a product to the wishlist
     * @param {CreateWishlistItemPayload} createWishlistItemPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public wishlistPost(createWishlistItemPayload: CreateWishlistItemPayload, options?: RawAxiosRequestConfig) {
        return WishlistApiFp(this.configuration).wishlistPost(createWishlistItemPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



